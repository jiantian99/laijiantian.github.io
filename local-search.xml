<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>快速认识Swagger</title>
    <link href="/2020/09/05/Swagger/"/>
    <url>/2020/09/05/Swagger/</url>
    
    <content type="html"><![CDATA[<h2 id="Swagger简介"><a href="#Swagger简介" class="headerlink" title="Swagger简介"></a>Swagger简介</h2><ul><li>号称世界上最流行的API框架</li><li>Restful Api 文档在线自动生成器 =&gt; <strong>API 文档 与API 定义同步更新</strong></li><li>直接运行，在线测试API</li><li>支持多种语言 （如：Java，PHP等）</li><li>官网：<a href="https://swagger.io/" target="_blank" rel="noopener">https://swagger.io/</a></li></ul><h2 id="Spring-Boot使用Swagger"><a href="#Spring-Boot使用Swagger" class="headerlink" title="Spring Boot使用Swagger"></a>Spring Boot使用Swagger</h2><p>要求：jdk1.8+</p><ol><li><p>导入Maven依赖：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-swagger2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></li><li><p>编写一个Controller，以供测试使用</p></li><li><p>编写swagger配置类 <code>SwaggerConfig</code></p><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>   <span class="hljs-comment">// 配置类</span><span class="hljs-meta">@EnableSwagger</span>2  <span class="hljs-comment">// 开启Swagger2自动配置</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SwaggerConfig</span> </span>&#123;&#125;</code></pre></li><li><p>访问<code>http://localhost:8080/swagger-ui.html</code>，查看到swagger的界面</p></li></ol><h2 id="配置Swagger"><a href="#配置Swagger" class="headerlink" title="配置Swagger"></a>配置Swagger</h2><ol><li><p>Swagger实例Bean是Docket，所以通过配置Docket实例来配置Swaggger</p><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">docket</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">// 关联上apiInfo</span>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.SWAGGER_2).apiInfo(apiInfo());&#125;</code></pre></li><li><p>通过<code>apiInfo</code>属性配置文档信息</p><pre><code class="hljs java"><span class="hljs-comment">// 配置Swagger信息</span><span class="hljs-function"><span class="hljs-keyword">private</span> ApiInfo <span class="hljs-title">apiInfo</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">// 填入联系人名称","联系人访问链接","联系人邮箱</span>    Contact contact=<span class="hljs-keyword">new</span> Contact(<span class="hljs-string">"Contact-name"</span>,<span class="hljs-string">"http://www."</span>,<span class="hljs-string">"contact@email.com"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ApiInfo(        <span class="hljs-string">"我的Swagger API文档"</span>,          <span class="hljs-comment">// 标题</span>        <span class="hljs-string">"学习使用Swagger"</span>,              <span class="hljs-comment">// 描述</span>        <span class="hljs-string">"v1.0"</span>,                        <span class="hljs-comment">// 版本号</span>        <span class="hljs-string">"https://www."</span>,                <span class="hljs-comment">// 组织链接</span>        contact,                       <span class="hljs-comment">// 联系人信息 </span>        <span class="hljs-string">"Apacch 2.0 许可"</span>,             <span class="hljs-comment">// 许可</span>        <span class="hljs-string">"http://www.apache.org/licenses/LICENSE-2.0"</span>,      <span class="hljs-comment">// 许可链接</span>        <span class="hljs-keyword">new</span> ArrayList&lt;&gt;()             <span class="hljs-comment">// 扩展</span>    );&#125;</code></pre></li></ol><h2 id="配置扫描接口"><a href="#配置扫描接口" class="headerlink" title="配置扫描接口"></a>配置扫描接口</h2><p>构建Docket时通过<code>select()</code>方法配置怎么扫描接口</p><p>通过<code>select()</code>方法，配置扫描接口<code>RequestHandlerSelectors</code>配置如何扫描接口</p><p>扫描方式：</p><ol><li><code>any()</code>   扫描所有接口</li><li><code>none()</code>  不扫描接口</li><li><code>withMethodAnnotation(final Class&lt;? extends Annotation&gt; annotation)</code> 扫描方法上的注解,如<code>withMethodAnnotation(GetMapping.class)</code>只扫描get请求</li><li><code>withClassAnnotation(final Class&lt;? extends Annotation&gt; annotation)</code> 扫描类上的注解,如<code>withClassAnnotation(Controller.class)</code>只扫描有controller注解的类中的接口</li><li><code>basePackage(final String basePackage)</code> 根据包的路径扫描接口</li></ol><p>使用</p><pre><code class="hljs java"><span class="hljs-comment">// 配置Docket以配置Swagger具体参数</span><span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">docket</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.SWAGGER_2)        .apiInfo(apiInfo())        .select()        <span class="hljs-comment">//.apis(RequestHandlerSelectors.any())    // 扫描所有接口</span>        <span class="hljs-comment">//.apis(RequestHandlerSelectors.none())   // 不扫描所有接口</span>        <span class="hljs-comment">//.apis(RequestHandlerSelectors.withMethodAnnotation(GetMapping.class))        // 扫描方法上有GetMapping的接口</span>        <span class="hljs-comment">//.apis(RequestHandlerSelectors.withClassAnnotation(Controller.class))         // 扫描类上有Controller的接口</span>        .apis(RequestHandlerSelectors.basePackage(<span class="hljs-string">"com.example.swagger.controller"</span>))   <span class="hljs-comment">// 扫描指定包路径下的接口</span>        .build();&#125;</code></pre><h3 id="配置接口扫描过滤"><a href="#配置接口扫描过滤" class="headerlink" title="配置接口扫描过滤"></a>配置接口扫描过滤</h3><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">docket</span><span class="hljs-params">()</span> </span>&#123;   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.SWAGGER_2)      .apiInfo(apiInfo())      .select()      .apis(RequestHandlerSelectors.basePackage(<span class="hljs-string">"com.example.swagger.controller"</span>))       <span class="hljs-comment">// 配置如何通过path过滤,即这里只扫描请求以/test开头的接口</span>      .paths(PathSelectors.ant(<span class="hljs-string">"/test/**"</span>))      .build();&#125;</code></pre><p>通过<code>.path(PathSelectors.)</code>配置接口扫描过滤</p><p>可选值有</p><ol><li><code>any()</code>  任何请求都扫描</li><li><code>none()</code> 任何请求都不扫描</li><li><code>regex()</code> 通过正则表达式控制</li><li><code>ant()</code> 通过字符串控制,如<code>&quot;/test/**&quot;</code></li></ol><h2 id="配置Swagger开关"><a href="#配置Swagger开关" class="headerlink" title="配置Swagger开关"></a>配置Swagger开关</h2><p>通过<code>enable()</code>方法配置是否启用swagger,默认为true,如果是false,则不能在浏览器中访问</p><h2 id="配置Swagger分组"><a href="#配置Swagger分组" class="headerlink" title="配置Swagger分组"></a>配置Swagger分组</h2><p>使用<code>.groupName()</code>,配置分组,参数为分组名,默认为 default</p><p>配置多个分组</p><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">docket1</span><span class="hljs-params">()</span></span>&#123;   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.SWAGGER_2).groupName(<span class="hljs-string">"group1"</span>);&#125;<span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">docket2</span><span class="hljs-params">()</span></span>&#123;   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.SWAGGER_2).groupName(<span class="hljs-string">"group2"</span>);&#125;<span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">docket3</span><span class="hljs-params">()</span></span>&#123;   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.SWAGGER_2).groupName(<span class="hljs-string">"group3"</span>);&#125;</code></pre><h2 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h2><ul><li><p><code>@Api(tag = &quot;xxx模块说明&quot;)</code></p><p>作用在模块类上</p></li><li><p><code>ApiOperation(&quot;xx接口说明&quot;)</code></p><p>作用在接口方法上</p></li><li><p><code>ApiModel(&quot;xxPojo说明&quot;)</code></p><p>作用在模型类上，如VO、BO</p></li><li><p><code>ApiModelProperty(value = &quot;xx属性说明&quot;,hidden = true)</code></p><p>作用在类方法和属性上，hidden为true时，隐藏该属性</p></li><li><p><code>ApiParm(&quot;xx参数说明&quot;)</code></p><p>作用在参数、方法和字段上</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Swagger，前后端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初识Redis</title>
    <link href="/2020/09/02/%E5%88%9D%E8%AF%86Redis/"/>
    <url>/2020/09/02/%E5%88%9D%E8%AF%86Redis/</url>
    
    <content type="html"><![CDATA[<h2 id="Redis入门"><a href="#Redis入门" class="headerlink" title="Redis入门"></a>Redis入门</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><blockquote><p>Redis 是什么</p></blockquote><p>Redis（<strong>Re</strong>mote <strong>Di</strong>ctionary <strong>S</strong>erver )，即远程字典服务，是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、<strong>Key-Value数据库</strong>，并提供多种语言的API。</p><p><a href="https://redis.io/" target="_blank" rel="noopener">官网</a>介绍：</p><p>Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 <a href="http://www.redis.cn/topics/data-types-intro.html#strings" target="_blank" rel="noopener">字符串（strings）</a>， <a href="http://www.redis.cn/topics/data-types-intro.html#hashes" target="_blank" rel="noopener">散列（hashes）</a>， <a href="http://www.redis.cn/topics/data-types-intro.html#lists" target="_blank" rel="noopener">列表（lists）</a>， <a href="http://www.redis.cn/topics/data-types-intro.html#sets" target="_blank" rel="noopener">集合（sets）</a>， <a href="http://www.redis.cn/topics/data-types-intro.html#sorted-sets" target="_blank" rel="noopener">有序集合（sorted sets）</a> 与范围查询， <a href="http://www.redis.cn/topics/data-types-intro.html#bitmaps" target="_blank" rel="noopener">bitmaps</a>， <a href="http://www.redis.cn/topics/data-types-intro.html#hyperloglogs" target="_blank" rel="noopener">hyperloglogs</a> 和 <a href="http://www.redis.cn/commands/geoadd.html" target="_blank" rel="noopener">地理空间（geospatial）</a> 索引半径查询。 Redis 内置了 <a href="http://www.redis.cn/topics/replication.html" target="_blank" rel="noopener">复制（replication）</a>，<a href="http://www.redis.cn/commands/eval.html" target="_blank" rel="noopener">LUA脚本（Lua scripting）</a>， <a href="http://www.redis.cn/topics/lru-cache.html" target="_blank" rel="noopener">LRU驱动事件（LRU eviction）</a>，<a href="http://www.redis.cn/topics/transactions.html" target="_blank" rel="noopener">事务（transactions）</a> 和不同级别的 <a href="http://www.redis.cn/topics/persistence.html" target="_blank" rel="noopener">磁盘持久化（persistence）</a>， 并通过 <a href="http://www.redis.cn/topics/sentinel.html" target="_blank" rel="noopener">Redis哨兵（Sentinel）</a>和自动 <a href="http://www.redis.cn/topics/cluster-tutorial.html" target="_blank" rel="noopener">分区（Cluster）</a>提供高可用性（high availability）。</p><h3 id="Redis基础"><a href="#Redis基础" class="headerlink" title="Redis基础"></a>Redis基础</h3><ul><li><p>Redis默认有16个数据库（DB 0~DB 15），默认使用第0个</p><p>使用<code>select 8</code>切换到DB 8，<code>dbsize</code>查看当前DB的大小，与key数量有关</p><p><code>keys *</code> 查看当前数据库所有key</p><p><code>flushdb</code>清空当前数据库所有key-value键值对</p><p><code>flushall</code>清空所有数据库使用key-value键值对</p></li><li><p>Redis默认是单线程，基于内存操作</p><p>Redis的性能瓶颈不是CPU，是机器内存和网络带宽</p></li></ul><h2 id="Redis-key"><a href="#Redis-key" class="headerlink" title="Redis-key"></a>Redis-key</h2><pre><code class="hljs bash">127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> name Tom     <span class="hljs-comment"># 设置键值对</span>OK127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> year 2020OK127.0.0.1:6379&gt; keys *           <span class="hljs-comment"># 查看所有键</span>1) <span class="hljs-string">"year"</span>2) <span class="hljs-string">"name"</span>127.0.0.1:6379&gt; move name 8      <span class="hljs-comment"># 移动键值对到指定的数据库 DB8</span>(<span class="hljs-built_in">integer</span>) 1127.0.0.1:6379&gt; exists name      <span class="hljs-comment"># exists 判断是否存在该键   0--不存在 1--存在</span>(<span class="hljs-built_in">integer</span>) 0127.0.0.1:6379&gt; select 8         <span class="hljs-comment"># 移动到DB8</span>OK127.0.0.1:6379[8]&gt; exists name(<span class="hljs-built_in">integer</span>) 1127.0.0.1:6379[8]&gt; del name      <span class="hljs-comment"># 删除键值对   返回删除的个数</span>(<span class="hljs-built_in">integer</span>) 1127.0.0.1:6379[8]&gt; keys *(empty array)127.0.0.1:6379[8]&gt; select 0      <span class="hljs-comment"># 移动到DB0</span>OK127.0.0.1:6379&gt; keys *1) <span class="hljs-string">"year"</span>127.0.0.1:6379&gt; ttl year         <span class="hljs-comment"># 查看key的过期剩余时间 当前key没有设置过期时间，返回-1</span>(<span class="hljs-built_in">integer</span>) -1127.0.0.1:6379&gt; expire year 10   <span class="hljs-comment"># expire 设置 key 的 过期时间 单位为秒</span>(<span class="hljs-built_in">integer</span>) 1127.0.0.1:6379&gt; ttl year         <span class="hljs-comment"># 查看key的过期剩余时间 单位为秒</span>(<span class="hljs-built_in">integer</span>) 6127.0.0.1:6379&gt; ttl year(<span class="hljs-built_in">integer</span>) 1127.0.0.1:6379&gt; ttl year         <span class="hljs-comment"># 当前key设置了过期时间，且key已过期，返回-2</span>(<span class="hljs-built_in">integer</span>) -2127.0.0.1:6379&gt; get year         <span class="hljs-comment"># key过期后，自动删除</span>(nil)127.0.0.1:6379&gt; keys *(empty array)127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> name MikeOK127.0.0.1:6379&gt; keys *1) <span class="hljs-string">"name"</span>127.0.0.1:6379&gt; get name<span class="hljs-string">"Mike"</span>127.0.0.1:6379&gt; rename name username      <span class="hljs-comment"># 修改key的名称</span>OK127.0.0.1:6379&gt; keys *1) <span class="hljs-string">"username"</span>127.0.0.1:6379&gt; get username<span class="hljs-string">"Mike"</span></code></pre><p>更多Redis-key命令，参考<a href="http://www.redis.cn/commands.html" target="_blank" rel="noopener">官方文档</a></p><h2 id="Redis五大数据类型"><a href="#Redis五大数据类型" class="headerlink" title="Redis五大数据类型"></a>Redis五大数据类型</h2><h3 id="String-字符串"><a href="#String-字符串" class="headerlink" title="String 字符串"></a>String 字符串</h3><pre><code class="hljs bash">127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> info helloOK127.0.0.1:6379&gt; get info<span class="hljs-string">"hello"</span>127.0.0.1:6379&gt; append info world          <span class="hljs-comment"># 向指定的key后追加value  成功返回追加后的字符串长度</span>(<span class="hljs-built_in">integer</span>) 10127.0.0.1:6379&gt; get info                   <span class="hljs-string">"helloworld"</span>127.0.0.1:6379&gt; strlen info                <span class="hljs-comment"># 获取key对应的value 字符串长度</span>(<span class="hljs-built_in">integer</span>) 10127.0.0.1:6379&gt; getrange info 5 7          <span class="hljs-comment"># 按起止位置（闭区间）获取字符串</span><span class="hljs-string">"wor"</span>127.0.0.1:6379&gt; getrange info 5 -1         <span class="hljs-comment"># 按起到最末位置</span><span class="hljs-string">"world"</span>127.0.0.1:6379&gt; setrange info 5 apple      <span class="hljs-comment"># 替换掉从该位置开始的value</span>(<span class="hljs-built_in">integer</span>) 10127.0.0.1:6379&gt; get info<span class="hljs-string">"helloapple"</span>127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> views 0OK127.0.0.1:6379&gt; incr views                 <span class="hljs-comment"># views++           返回增加后的值</span>(<span class="hljs-built_in">integer</span>) 1127.0.0.1:6379&gt; incrby views 10            <span class="hljs-comment"># 按照指定的步长增加  返回增加后的值</span>(<span class="hljs-built_in">integer</span>) 11127.0.0.1:6379&gt; decr views                 <span class="hljs-comment"># views--           返回增加后的值</span>(<span class="hljs-built_in">integer</span>) 10127.0.0.1:6379&gt; decrby views 8             <span class="hljs-comment"># 按照指定的步长减少  返回增加后的值</span>(<span class="hljs-built_in">integer</span>) 2127.0.0.1:6379&gt; incrbyfloat views 0.8      <span class="hljs-comment"># 增加浮点数       </span><span class="hljs-string">"2.8"</span>127.0.0.1:6379&gt; setnx views 2              <span class="hljs-comment"># 仅当key不存在时，进行set  失败返回0</span>(<span class="hljs-built_in">integer</span>) 0127.0.0.1:6379&gt; getset info hi             <span class="hljs-comment"># 先get 再set   如果不存在返回nil</span><span class="hljs-string">"helloapple"</span>127.0.0.1:6379&gt; get info<span class="hljs-string">"hi"</span>127.0.0.1:6379&gt; mset k1 v1 k2 v2 k3 v3     <span class="hljs-comment"># 批量set</span>OK127.0.0.1:6379&gt; keys *1) <span class="hljs-string">"info"</span>2) <span class="hljs-string">"k2"</span>3) <span class="hljs-string">"k1"</span>4) <span class="hljs-string">"k3"</span>127.0.0.1:6379&gt; mget k1 k2 k3              <span class="hljs-comment"># 批量get</span>1) <span class="hljs-string">"v1"</span>2) <span class="hljs-string">"v2"</span>3) <span class="hljs-string">"v3"</span>127.0.0.1:6379&gt; msetnx k1 v1 k4 v4         <span class="hljs-comment"># 批量setnx 原子性---全为真才执行</span>(<span class="hljs-built_in">integer</span>) 0</code></pre><p>String 的value可以是字符串或者数字</p><p>场景：</p><ul><li>计数器</li><li>对象存储缓存</li><li>统计多单位的数量 ：  set uid:1001:views 100</li></ul><h3 id="List-列表"><a href="#List-列表" class="headerlink" title="List 列表"></a>List 列表</h3><p><img src="https://gitee.com/jiantian99/Images-Hosting/raw/master/img/20200907230115.png" srcset="/img/loading.gif" alt></p><p>Redis中List可以双向操作，大部分命令可以分为Lxxx和Rxxx两种，部分命令L代表List，如LLEN、LRANGE</p><pre><code class="hljs bash"><span class="hljs-comment"># LPUSH RPUSH LRANGE</span>127.0.0.1:6379&gt; lpush list k1          <span class="hljs-comment"># 从左边向列表push一个或多个值</span>(<span class="hljs-built_in">integer</span>) 1127.0.0.1:6379&gt; lpush list k2 k3(<span class="hljs-built_in">integer</span>) 3127.0.0.1:6379&gt; lrange list 0 1        <span class="hljs-comment"># 获取list起止位置的值，从左到右</span>1) <span class="hljs-string">"k3"</span>2) <span class="hljs-string">"k2"</span>127.0.0.1:6379&gt; lrange list 0 -1       <span class="hljs-comment"># 获取list所有元素</span>1) <span class="hljs-string">"k3"</span>2) <span class="hljs-string">"k2"</span>3) <span class="hljs-string">"k1"</span>127.0.0.1:6379&gt; get list               <span class="hljs-comment"># 无法使用get 获取list的值</span>(error) WRONGTYPE Operation against a key holding the wrong kind of value127.0.0.1:6379&gt; rpush list k4          <span class="hljs-comment"># 从右边push一个或多个值</span>(<span class="hljs-built_in">integer</span>) 4127.0.0.1:6379&gt; rpush list k5 k6(<span class="hljs-built_in">integer</span>) 6127.0.0.1:6379&gt; lrange list 0 -11) <span class="hljs-string">"k3"</span>2) <span class="hljs-string">"k2"</span>3) <span class="hljs-string">"k1"</span>4) <span class="hljs-string">"k4"</span>5) <span class="hljs-string">"k5"</span>6) <span class="hljs-string">"k6"</span><span class="hljs-comment">################################################################################</span><span class="hljs-comment"># LPUSHX RPUSHX</span>127.0.0.1:6379&gt; lpushx newlist k1      <span class="hljs-comment"># 向已存在的list push值 失败返回0</span>(<span class="hljs-built_in">integer</span>) 0127.0.0.1:6379&gt; lpushx list k7         <span class="hljs-comment"># 向已存在的list从左push值 成功返回list值的数量</span>(<span class="hljs-built_in">integer</span>) 7127.0.0.1:6379&gt; rpushx list k9         <span class="hljs-comment"># 向已存在的list从右push值 成功返回list值的数量</span>(<span class="hljs-built_in">integer</span>) 8127.0.0.1:6379&gt; lrange list 0 -11) <span class="hljs-string">"k7"</span>2) <span class="hljs-string">"k3"</span>3) <span class="hljs-string">"k2"</span>4) <span class="hljs-string">"k1"</span>5) <span class="hljs-string">"k4"</span>6) <span class="hljs-string">"k5"</span>7) <span class="hljs-string">"k6"</span>8) <span class="hljs-string">"k9"</span><span class="hljs-comment">################################################################################</span><span class="hljs-comment"># LINSERT LLEN LINDEX LSET</span>127.0.0.1:6379&gt; linsert list before k3 k1        <span class="hljs-comment"># 在list中指定元素前或后插入value</span>(<span class="hljs-built_in">integer</span>) 9127.0.0.1:6379&gt; lrange list 0 -11) <span class="hljs-string">"k7"</span>2) <span class="hljs-string">"k1"</span>3) <span class="hljs-string">"k3"</span>4) <span class="hljs-string">"k2"</span>5) <span class="hljs-string">"k1"</span>6) <span class="hljs-string">"k4"</span>7) <span class="hljs-string">"k5"</span>8) <span class="hljs-string">"k6"</span>9) <span class="hljs-string">"k9"</span>127.0.0.1:6379&gt; llen list                        <span class="hljs-comment"># 获取list长度</span>(<span class="hljs-built_in">integer</span>) 9127.0.0.1:6379&gt; lindex list 5                    <span class="hljs-comment"># 根据下标获取值</span><span class="hljs-string">"k4"</span>127.0.0.1:6379&gt; lset list 5 k7                   <span class="hljs-comment"># 将指定下标的元素 设成指定值</span>OK127.0.0.1:6379&gt; lrange list 0 -11) <span class="hljs-string">"k7"</span>2) <span class="hljs-string">"k1"</span>3) <span class="hljs-string">"k3"</span>4) <span class="hljs-string">"k2"</span>5) <span class="hljs-string">"k1"</span>6) <span class="hljs-string">"k7"</span>7) <span class="hljs-string">"k5"</span>8) <span class="hljs-string">"k6"</span>9) <span class="hljs-string">"k9"</span><span class="hljs-comment">################################################################################</span><span class="hljs-comment"># LPOP RPOP</span>127.0.0.1:6379&gt; lpop list           <span class="hljs-comment"># 从最左移除值，并返回</span><span class="hljs-string">"k7"</span>127.0.0.1:6379&gt; rpop list           <span class="hljs-comment"># 从最右移除值，并返回</span><span class="hljs-string">"k9"</span>127.0.0.1:6379&gt; lrange list 0 -11) <span class="hljs-string">"k1"</span>2) <span class="hljs-string">"k3"</span>3) <span class="hljs-string">"k2"</span>4) <span class="hljs-string">"k1"</span>5) <span class="hljs-string">"k7"</span>6) <span class="hljs-string">"k5"</span>7) <span class="hljs-string">"k6"</span><span class="hljs-comment">################################################################################</span><span class="hljs-comment"># RPOPLPUSH</span>127.0.0.1:6379&gt; rpoplpush list newlist    <span class="hljs-comment"># 将list的右边最后一个值弹出，并push进另一个列表头部</span><span class="hljs-string">"k6"</span>127.0.0.1:6379&gt; lrange list 0 -11) <span class="hljs-string">"k1"</span>2) <span class="hljs-string">"k3"</span>3) <span class="hljs-string">"k2"</span>4) <span class="hljs-string">"k1"</span>5) <span class="hljs-string">"k7"</span>6) <span class="hljs-string">"k5"</span>127.0.0.1:6379&gt; lrange newlist 0 -11) <span class="hljs-string">"k6"</span><span class="hljs-comment"># LTRIM</span>127.0.0.1:6379&gt; ltrim list 0 2             <span class="hljs-comment"># 截取指定区间的列表 </span>OK127.0.0.1:6379&gt; lrange list 0 -11) <span class="hljs-string">"k1"</span>2) <span class="hljs-string">"k3"</span>3) <span class="hljs-string">"k2"</span><span class="hljs-comment">################################################################################</span><span class="hljs-comment"># LREM</span>127.0.0.1:6379&gt; lrange list 0 -11) <span class="hljs-string">"k2"</span>2) <span class="hljs-string">"k5"</span>3) <span class="hljs-string">"k5"</span>4) <span class="hljs-string">"k1"</span>5) <span class="hljs-string">"k3"</span>6) <span class="hljs-string">"k2"</span>7) <span class="hljs-string">"k5"</span>127.0.0.1:6379&gt; lrem list 2 k5          <span class="hljs-comment"># 从头部开始搜索，最多删除2个k5</span>(<span class="hljs-built_in">integer</span>) 2127.0.0.1:6379&gt; lrange list 0 -11) <span class="hljs-string">"k2"</span>2) <span class="hljs-string">"k1"</span>3) <span class="hljs-string">"k3"</span>4) <span class="hljs-string">"k2"</span>5) <span class="hljs-string">"k5"</span>127.0.0.1:6379&gt; lrem list -1 k2          <span class="hljs-comment"># 从尾部开始搜索，最多删除1个k2</span>(<span class="hljs-built_in">integer</span>) 1127.0.0.1:6379&gt; lrange list 0 -11) <span class="hljs-string">"k2"</span>2) <span class="hljs-string">"k1"</span>3) <span class="hljs-string">"k3"</span>4) <span class="hljs-string">"k5"</span><span class="hljs-comment">################################################################################</span><span class="hljs-comment"># BLPOP  BRPOP</span>127.0.0.1:6379&gt; lrange list 0 -11) <span class="hljs-string">"k2"</span>2) <span class="hljs-string">"k1"</span>3) <span class="hljs-string">"k3"</span>4) <span class="hljs-string">"k5"</span>127.0.0.1:6379&gt; lrange newlist 0 -11) <span class="hljs-string">"k6"</span>127.0.0.1:6379&gt; blpop newlist list 10      <span class="hljs-comment"># 从左边移除并获取第一个元素，如果列表中没有从候选列表中获取</span>1) <span class="hljs-string">"newlist"</span>                               <span class="hljs-comment"># 返回弹出元素所属列表 和 元素</span>2) <span class="hljs-string">"k6"</span>127.0.0.1:6379&gt; blpop newlist list 10      <span class="hljs-comment"># newlist为空，则从候选列表 list 中获取</span>1) <span class="hljs-string">"list"</span>2) <span class="hljs-string">"k2"</span>127.0.0.1:6379&gt; blpop newlist 10           <span class="hljs-comment"># 列表中没有元素会阻塞列表，直到超时或者发现有可弹出对象</span>(nil)(10.01s)127.0.0.1:6379&gt; blpop newlist 301) <span class="hljs-string">"newlist"</span>2) <span class="hljs-string">"k9"</span>(4.79s)127.0.0.1:6379&gt; brpop newlist 30           <span class="hljs-comment"># 在等待的时候，向newlist push进k9，阻塞得到解决</span>1) <span class="hljs-string">"newlist"</span>                               2) <span class="hljs-string">"k9"</span>(2.52s)                                    <span class="hljs-comment"># 返回等待时间</span></code></pre><blockquote><p>总结</p></blockquote><ul><li><p>list实际上是一个双向链表，left、right，before 节点 after 都可以插入值</p></li><li><p>如果key不存在，创建新链表</p></li><li><p>如果key存在，在列表中新增内容</p></li><li><p>如果移除了所有值，链表为空，即代表不存在</p></li><li><p>在列表两边插入或改动值，效率最高，列表中间效率较低</p></li><li><p>应用：</p><p>消息排队，消息队列（LPUSH，RPOP），栈（LPUSH，LPOP）</p></li></ul><h3 id="Set-集合"><a href="#Set-集合" class="headerlink" title="Set 集合"></a>Set 集合</h3><p>Redis中的set是String类型的<strong>无序集合</strong>，集合成员<strong>唯一</strong>，集合中不能出现重复数据</p><p>Set集合是通过<strong>哈希表</strong>实现，增删查的复杂度都是O(1)</p><pre><code class="hljs bash"><span class="hljs-comment"># SADD SCARD SMEMBERS SISMEMBER</span>127.0.0.1:6379&gt; SADD myset s1               <span class="hljs-comment"># 向集合myset中添加一个成员 s1</span>(<span class="hljs-built_in">integer</span>) 1127.0.0.1:6379&gt; SADD myset s2 s3            <span class="hljs-comment"># 向集合myset中添加多个成员</span>(<span class="hljs-built_in">integer</span>) 2127.0.0.1:6379&gt; scard myset                 <span class="hljs-comment"># 获取集合中成员的数量</span>(<span class="hljs-built_in">integer</span>) 3127.0.0.1:6379&gt; smembers myset              <span class="hljs-comment"># 获取集合中所有成员</span>1) <span class="hljs-string">"s1"</span>2) <span class="hljs-string">"s3"</span>3) <span class="hljs-string">"s2"</span>127.0.0.1:6379&gt; SISMEMBER myset s2          <span class="hljs-comment"># 查询 s2 是否是myset的成员</span>(<span class="hljs-built_in">integer</span>) 1                                 <span class="hljs-comment"># 是 返回 1</span>127.0.0.1:6379&gt; SISMEMBER myset s6(<span class="hljs-built_in">integer</span>) 0                                 <span class="hljs-comment"># 不是 返回 0</span><span class="hljs-comment">################################################################################</span><span class="hljs-comment"># SRANDMEMBER SPOP</span>127.0.0.1:6379&gt; SRANDMEMBER myset           <span class="hljs-comment"># 随机返回1个成员</span><span class="hljs-string">"s2"</span>127.0.0.1:6379&gt; SRANDMEMBER myset 2         <span class="hljs-comment"># 随机返回2个成员</span>1) <span class="hljs-string">"s1"</span>2) <span class="hljs-string">"s2"</span>127.0.0.1:6379&gt; SPOP myset 2                <span class="hljs-comment"># 随机移除并返回2个成员</span>1) <span class="hljs-string">"s3"</span>2) <span class="hljs-string">"s2"</span>127.0.0.1:6379&gt; SMEMBERS myset1) <span class="hljs-string">"s1"</span><span class="hljs-comment">################################################################################</span><span class="hljs-comment"># SMOVE SREM</span>127.0.0.1:6379&gt; SMEMBERS myset1) <span class="hljs-string">"s4"</span>2) <span class="hljs-string">"s1"</span>3) <span class="hljs-string">"s3"</span>4) <span class="hljs-string">"s2"</span>5) <span class="hljs-string">"s5"</span>127.0.0.1:6379&gt; SMEMBERS newset(empty array)127.0.0.1:6379&gt; SMOVE myset newset s1      <span class="hljs-comment"># 将myset中的s1成员移动到newset中</span>(<span class="hljs-built_in">integer</span>) 1127.0.0.1:6379&gt; SMEMBERS myset1) <span class="hljs-string">"s3"</span>2) <span class="hljs-string">"s2"</span>3) <span class="hljs-string">"s4"</span>4) <span class="hljs-string">"s5"</span>127.0.0.1:6379&gt; SMEMBERS newset1) <span class="hljs-string">"s1"</span>127.0.0.1:6379&gt; SREM newset s1             <span class="hljs-comment"># 删除newset集合中指定成员 s1</span>(<span class="hljs-built_in">integer</span>) 1127.0.0.1:6379&gt; SMEMBERS newset(empty array)<span class="hljs-comment">################################################################################</span><span class="hljs-comment"># SDIFF SINTER SUNION</span><span class="hljs-comment"># set1 &#123;s1,s2,s3&#125; set2 &#123;s3,s4&#125; set3 &#123;s3,s5&#125; </span>127.0.0.1:6379&gt; SDIFF set1 set2 set3       <span class="hljs-comment"># 差集 等价于 set1-set2-set3</span>1) <span class="hljs-string">"s1"</span>2) <span class="hljs-string">"s2"</span>127.0.0.1:6379&gt; SDIFF set2 set3            <span class="hljs-comment"># 差集 等价于 set2-set3</span>1) <span class="hljs-string">"s4"</span>127.0.0.1:6379&gt; SINTER set1 set2 set3      <span class="hljs-comment"># 交集 </span>1) <span class="hljs-string">"s3"</span>127.0.0.1:6379&gt; SUNION set1 set2           <span class="hljs-comment"># 并集 相当于set1+set2</span>1) <span class="hljs-string">"s4"</span>2) <span class="hljs-string">"s1"</span>3) <span class="hljs-string">"s2"</span>4) <span class="hljs-string">"s3"</span>127.0.0.1:6379&gt; SUNION set1 set2 set3      <span class="hljs-comment"># 并集 相当于set1+set2+set3</span>1) <span class="hljs-string">"s1"</span>2) <span class="hljs-string">"s3"</span>3) <span class="hljs-string">"s2"</span>4) <span class="hljs-string">"s4"</span>5) <span class="hljs-string">"s5"</span></code></pre><h3 id="Hash-哈希"><a href="#Hash-哈希" class="headerlink" title="Hash 哈希"></a>Hash 哈希</h3><p>Redis 中 Hash是一个String类型的field和value映射表，Hash适合存储对象，经常变更的信息，如用户信息；String更适合字符串存储。</p><pre><code class="hljs bash"><span class="hljs-comment"># HSET HMSET HSETNX</span>127.0.0.1:6379&gt; HSET user name Mike           <span class="hljs-comment"># 把user哈希表作为一个对象 设置name为Mike</span>(<span class="hljs-built_in">integer</span>) 1127.0.0.1:6379&gt; HSET user name Tome           <span class="hljs-comment"># 重复设置同一个field会覆盖，且返回0 </span>(<span class="hljs-built_in">integer</span>) 0127.0.0.1:6379&gt; HMSET user age 18 sex 1       <span class="hljs-comment"># 同时将多个field-value 设置到Hash中</span>OK127.0.0.1:6379&gt; HSETNX user name Joe          <span class="hljs-comment"># 只有field不存在时，才可设置</span>(<span class="hljs-built_in">integer</span>) 0                                   <span class="hljs-comment"># 失败返回 0</span>127.0.0.1:6379&gt; HSETNX user id 1001(<span class="hljs-built_in">integer</span>) 1                                   <span class="hljs-comment"># 成功返回 1</span><span class="hljs-comment">######################################################################################</span><span class="hljs-comment"># HEXISTS</span>127.0.0.1:6379&gt; HEXISTS user name             <span class="hljs-comment"># 判断是否存在field 存在返回 1</span>(<span class="hljs-built_in">integer</span>) 1127.0.0.1:6379&gt; HEXISTS user email            <span class="hljs-comment"># 不存在返回 0</span>(<span class="hljs-built_in">integer</span>) 0<span class="hljs-comment">######################################################################################</span><span class="hljs-comment"># HGET HMGET HGETALL</span>127.0.0.1:6379&gt; HGET user name                <span class="hljs-comment"># 获取user中name字段的value</span><span class="hljs-string">"Tome"</span>127.0.0.1:6379&gt; HMGET user name age id        <span class="hljs-comment"># 获取多个field-value</span>1) <span class="hljs-string">"Tome"</span>2) <span class="hljs-string">"18"</span>3) <span class="hljs-string">"1001"</span>127.0.0.1:6379&gt; HGETALL user                  <span class="hljs-comment"># 获取所有field-value</span>1) <span class="hljs-string">"name"</span>                                     <span class="hljs-comment"># field</span>2) <span class="hljs-string">"Tome"</span>                                     <span class="hljs-comment"># value</span>3) <span class="hljs-string">"age"</span>4) <span class="hljs-string">"18"</span>5) <span class="hljs-string">"sex"</span>6) <span class="hljs-string">"1"</span>7) <span class="hljs-string">"id"</span>8) <span class="hljs-string">"1001"</span>127.0.0.1:6379&gt; <span class="hljs-comment">######################################################################################</span><span class="hljs-comment"># HKEYS HLEN HVALS</span>127.0.0.1:6379&gt; HKEYS user                    <span class="hljs-comment"># 获取哈希表中所有field</span>1) <span class="hljs-string">"name"</span> 2) <span class="hljs-string">"age"</span>3) <span class="hljs-string">"sex"</span>4) <span class="hljs-string">"id"</span>127.0.0.1:6379&gt; HLEN user                     <span class="hljs-comment"># 获取哈希表中field的数量</span>(<span class="hljs-built_in">integer</span>) 4127.0.0.1:6379&gt; HVALS user                    <span class="hljs-comment"># 获取哈希表中所有value</span>1) <span class="hljs-string">"Tome"</span>2) <span class="hljs-string">"18"</span>3) <span class="hljs-string">"1"</span>4) <span class="hljs-string">"1001"</span><span class="hljs-comment">######################################################################################</span><span class="hljs-comment"># HINCRBY</span>127.0.0.1:6379&gt; HINCRBY user age 1            <span class="hljs-comment"># 给哈希表中指定field的整数量+1 返回增量后的结果</span>(<span class="hljs-built_in">integer</span>) 19127.0.0.1:6379&gt; HINCRBY user name 1           <span class="hljs-comment"># 只适用于整数型字段</span>(error) ERR <span class="hljs-built_in">hash</span> value is not an <span class="hljs-built_in">integer</span><span class="hljs-comment">######################################################################################</span><span class="hljs-comment"># HDEL</span>127.0.0.1:6379&gt; HDEL user sex id              <span class="hljs-comment"># 删除一个或多个字段</span>(<span class="hljs-built_in">integer</span>) 2127.0.0.1:6379&gt; HKEYS user1) <span class="hljs-string">"name"</span>2) <span class="hljs-string">"age"</span></code></pre><h3 id="Zset-有序集合"><a href="#Zset-有序集合" class="headerlink" title="Zset 有序集合"></a>Zset 有序集合</h3><p>以Set相比，Zset每个元素都会关联一个<code>double</code>类型的<code>score</code>，redis按照<code>score</code>对成员从小到大进行排序<code>score</code>相同，按字典顺序排序。</p><p>Zset中，成员唯一，score不唯一</p><p>应用：</p><ul><li>排序：成绩表、工资表</li><li>排行榜</li><li>消息：重要消息，带权重判断</li></ul><pre><code class="hljs bash"><span class="hljs-comment"># ZADD ZCARD ZCOUNT</span>127.0.0.1:6379&gt; ZADD price 1 apple       <span class="hljs-comment"># 向Zset中添加一个成员 apple 且 score=1</span>(<span class="hljs-built_in">integer</span>) 1127.0.0.1:6379&gt; ZADD price 3 watermelon 5 lemon 8 peach 10 grape 12 cherry(<span class="hljs-built_in">integer</span>) 5                              <span class="hljs-comment"># 向Zset中添加多个成员及其score，返回添加个数</span>127.0.0.1:6379&gt; ZCARD price              <span class="hljs-comment"># 获取Zset中成员数</span>(<span class="hljs-built_in">integer</span>) 6127.0.0.1:6379&gt; ZCOUNT price 0 5         <span class="hljs-comment"># 获取score在 [0,5]区间的成员数量</span>(<span class="hljs-built_in">integer</span>) 3<span class="hljs-comment">######################################################################################</span><span class="hljs-comment"># ZINCRBY ZSCORE</span>127.0.0.1:6379&gt; ZINCRBY price 5 cherry   <span class="hljs-comment"># 将成员 cherry score +5</span><span class="hljs-string">"17"</span>                                     <span class="hljs-comment"># 返回增加后的score</span>127.0.0.1:6379&gt; ZSCORE price cherry      <span class="hljs-comment"># 获取成员 cherry 的score</span><span class="hljs-string">"17"</span>127.0.0.1:6379&gt; ZSCORE price lemon<span class="hljs-string">"5"</span><span class="hljs-comment">######################################################################################</span><span class="hljs-comment"># ZRANK ZRANGE</span>127.0.0.1:6379&gt; ZRANGE price 0 3         <span class="hljs-comment"># 获取索引在 0 - 1 之间的成员</span>1) <span class="hljs-string">"apple"</span>2) <span class="hljs-string">"watermelon"</span>3) <span class="hljs-string">"lemon"</span>4) <span class="hljs-string">"peach"</span>127.0.0.1:6379&gt; ZRANGE price 0 -1        <span class="hljs-comment"># 获取所有成员</span>1) <span class="hljs-string">"apple"</span>2) <span class="hljs-string">"watermelon"</span>3) <span class="hljs-string">"lemon"</span>4) <span class="hljs-string">"peach"</span>5) <span class="hljs-string">"grape"</span>6) <span class="hljs-string">"cherry"</span>127.0.0.1:6379&gt; ZRANK price lemon        <span class="hljs-comment"># 获取lemon的索引</span>(<span class="hljs-built_in">integer</span>) 2<span class="hljs-comment">######################################################################################</span><span class="hljs-comment"># ZRANGEBYLEX                            通过字典区间返回有序集合的成员</span>127.0.0.1:6379&gt; zrangebylex price - +    <span class="hljs-comment"># 返回所有成员</span>1) <span class="hljs-string">"apple"</span>2) <span class="hljs-string">"watermelon"</span>3) <span class="hljs-string">"lemon"</span>4) <span class="hljs-string">"peach"</span>5) <span class="hljs-string">"grape"</span>6) <span class="hljs-string">"cherry"</span><span class="hljs-comment">######################################################################################</span><span class="hljs-comment"># ZRANGEBYSCORE</span>127.0.0.1:6379&gt; ZRANGEBYSCORE price 1 10 <span class="hljs-comment"># 返回score 在[1,10]之间的成员</span>1) <span class="hljs-string">"apple"</span>2) <span class="hljs-string">"watermelon"</span>3) <span class="hljs-string">"lemon"</span>4) <span class="hljs-string">"peach"</span>5) <span class="hljs-string">"grape"</span><span class="hljs-comment">######################################################################################</span><span class="hljs-comment"># ZLEXCOUNT      </span>127.0.0.1:6379&gt; ZLEXCOUNT price - +      <span class="hljs-comment"># 返回指定字典区间的成员数量</span>(<span class="hljs-built_in">integer</span>) 6<span class="hljs-comment">######################################################################################</span><span class="hljs-comment"># ZREM ZREMRANGEBYLEX  ZREMRANGBYRANK  ZREMRANGEBYSCORE</span>127.0.0.1:6379&gt; ZREM price cherry             <span class="hljs-comment"># 删除指定成员</span>(<span class="hljs-built_in">integer</span>) 1127.0.0.1:6379&gt; ZREM myset [a [b(<span class="hljs-built_in">integer</span>) 0127.0.0.1:6379&gt; ZREMRANGEBYLEX myset [a [b    <span class="hljs-comment"># 删除指定字典区间成员</span>(<span class="hljs-built_in">integer</span>) 2127.0.0.1:6379&gt; ZREMRANGEBYRANK price 0 1     <span class="hljs-comment"># 删除排名0-1的成员</span>(<span class="hljs-built_in">integer</span>) 2127.0.0.1:6379&gt; ZREMRANGEBYSCORE price 5 8    <span class="hljs-comment"># 删除score在[5,8]之间的成员</span>(<span class="hljs-built_in">integer</span>) 2<span class="hljs-comment">######################################################################################</span><span class="hljs-comment"># ZREVRANGE     ZREVRANGEBYSCORE    ZREVRANGEBYLEX    ZREVRANK</span><span class="hljs-comment"># myset&#123;(m1,0),(m2,0),(m3,0),(m4,1),(m5,2),(m6,3)&#125;</span>127.0.0.1:6379&gt; ZREVRANGE myset 0 2           <span class="hljs-comment"># 按score递减排序，返回指定索引结果</span>1) <span class="hljs-string">"m6"</span>2) <span class="hljs-string">"m5"</span>3) <span class="hljs-string">"m4"</span>127.0.0.1:6379&gt; ZREVRANGEBYSCORE myset 3 1    <span class="hljs-comment"># 按score递减排序，返回score在[1,3]结果</span>1) <span class="hljs-string">"m6"</span>2) <span class="hljs-string">"m5"</span>3) <span class="hljs-string">"m4"</span>127.0.0.1:6379&gt; ZREVRANGEBYLEX myset [m3 (m1  <span class="hljs-comment"># 按字典递减排序，返回集合中(m1,m3]结果</span>1) <span class="hljs-string">"m3"</span>2) <span class="hljs-string">"m2"</span>127.0.0.1:6379&gt; ZREVRANK myset m3             <span class="hljs-comment"># 按score递减排序，返回m3的索引</span>(<span class="hljs-built_in">integer</span>) 3<span class="hljs-comment">######################################################################################</span><span class="hljs-comment"># ZINTERSTOR   ZUNIONSTORE</span><span class="hljs-comment"># math&#123;(Mike,90),(Tom,88),(JOe,80)&#125;</span><span class="hljs-comment"># math&#123;(Mike,88),(Tom,76),(JOe,90)&#125;</span>127.0.0.1:6379&gt; ZINTERSTORE sum 2 math en     <span class="hljs-comment"># 将math 和 en进行合并，存放到sum中</span>(<span class="hljs-built_in">integer</span>) 3127.0.0.1:6379&gt; ZRANGE sum 0 -1 withscores    <span class="hljs-comment"># 合并后的Zset score是两集合中score之和</span>1) <span class="hljs-string">"Tom"</span>2) <span class="hljs-string">"164"</span>3) <span class="hljs-string">"Joe"</span>4) <span class="hljs-string">"170"</span>5) <span class="hljs-string">"Mike"</span>6) <span class="hljs-string">"178"</span>127.0.0.1:6379&gt; ZUNIONSTORE low 2 marh en AGGREGATE MIN(<span class="hljs-built_in">integer</span>) 3                                   <span class="hljs-comment"># 取两个集合的成员score最小值作为结果</span>127.0.0.1:6379&gt; ZRANGE low 0 -1 withscores1) <span class="hljs-string">"Tom"</span>2) <span class="hljs-string">"76"</span>3) <span class="hljs-string">"Mike"</span>4) <span class="hljs-string">"88"</span>5) <span class="hljs-string">"Joe"</span>6) <span class="hljs-string">"90"</span></code></pre><h2 id="Redis三种特殊数据类型"><a href="#Redis三种特殊数据类型" class="headerlink" title="Redis三种特殊数据类型"></a>Redis三种特殊数据类型</h2><h3 id="Geospatial-地理位置"><a href="#Geospatial-地理位置" class="headerlink" title="Geospatial(地理位置)"></a>Geospatial(地理位置)</h3><p>Geospatial是使用经纬度定位地理坐标并用一个<strong>有序集合zset保存</strong>，所以Zset命令也可以使用</p><blockquote><p>有效经纬度</p></blockquote><p>经度[-180,180]    纬度[-85.05112878,85.05112878]</p><pre><code class="hljs bash"><span class="hljs-comment"># GEOADD</span>127.0.0.1:6379&gt; GEOADD china:city 116.405285 39.904989 beijing       <span class="hljs-comment"># 将具体经纬度的坐标存入一个有序集合</span>(<span class="hljs-built_in">integer</span>) 1127.0.0.1:6379&gt; GEOADD china:city 121.472644 31.231706 shanghai(<span class="hljs-built_in">integer</span>) 1127.0.0.1:6379&gt; GEOADD china:city 113.280637 23.125178 guangzhou(<span class="hljs-built_in">integer</span>) 1127.0.0.1:6379&gt; GEOADD china:city 114.085947 22.547 shenzhen(<span class="hljs-built_in">integer</span>) 1127.0.0.1:6379&gt; GEOADD china:city 114.177314 22.266416 hongkong(<span class="hljs-built_in">integer</span>) 1<span class="hljs-comment">######################################################################################</span><span class="hljs-comment"># GEOPOS       获取集合中的一个/多个成员坐标</span>127.0.0.1:6379&gt; GEOPOS china:city beijing               1) 1) <span class="hljs-string">"116.40528291463851929"</span>   2) <span class="hljs-string">"39.9049884229125027"</span>127.0.0.1:6379&gt; GEOPOS china:city beijing hongkong1) 1) <span class="hljs-string">"116.40528291463851929"</span>   2) <span class="hljs-string">"39.9049884229125027"</span>2) 1) <span class="hljs-string">"114.17731136083602905"</span>   2) <span class="hljs-string">"22.26641644428547551"</span><span class="hljs-comment">######################################################################################</span><span class="hljs-comment"># GEODIST      返回两个给定位置之间的距离 默认为m</span><span class="hljs-comment"># 单位参数 m-米 km-千米 mi-英里 ft-英尺</span>127.0.0.1:6379&gt; GEODIST china:city guangzhou shenzhen km<span class="hljs-string">"104.6426"</span>127.0.0.1:6379&gt; GEODIST china:city guangzhou hongkong m<span class="hljs-string">"132624.2824"</span><span class="hljs-comment">######################################################################################</span><span class="hljs-comment"># GEORADIUS 给定的经纬度为中心， 返回集合包含的位置元素</span>127.0.0.1:6379&gt; GEORADIUS china:city 115 22.6 100 km  <span class="hljs-comment"># 给定的经纬度为中心 100 km以内</span>1) <span class="hljs-string">"hongkong"</span>2) <span class="hljs-string">"shenzhen"</span>127.0.0.1:6379&gt; GEORADIUS china:city 115 22.6 100 km withdist  <span class="hljs-comment"># 附带距给定位置举例</span>1) 1) <span class="hljs-string">"hongkong"</span>   2) <span class="hljs-string">"92.3601"</span>2) 1) <span class="hljs-string">"shenzhen"</span>   2) <span class="hljs-string">"94.0628"</span>127.0.0.1:6379&gt; GEORADIUS china:city 115 22.6 100 km withcoord  <span class="hljs-comment"># 附带城市的定位信息</span>1) 1) <span class="hljs-string">"hongkong"</span>   2) 1) <span class="hljs-string">"114.17731136083602905"</span>      2) <span class="hljs-string">"22.26641644428547551"</span>2) 1) <span class="hljs-string">"shenzhen"</span>   2) 1) <span class="hljs-string">"114.08594459295272827"</span>      2) <span class="hljs-string">"22.54699993773966327"</span>127.0.0.1:6379&gt; GEORADIUS china:city 115 22.6 100 km withdist withcoord count 1  <span class="hljs-comment"># 筛选出最近的 1 个</span>1) 1) <span class="hljs-string">"hongkong"</span>   2) <span class="hljs-string">"92.3601"</span>   3) 1) <span class="hljs-string">"114.17731136083602905"</span>      2) <span class="hljs-string">"22.26641644428547551"</span>     <span class="hljs-comment">######################################################################################</span><span class="hljs-comment"># GEORADIUSBYMEMBER 返回指定元素周围的其他元素     </span>127.0.0.1:6379&gt; GEORADIUSBYMEMBER china:city shenzhen 500 km1) <span class="hljs-string">"hongkong"</span>2) <span class="hljs-string">"shenzhen"</span>3) <span class="hljs-string">"guangzhou"</span><span class="hljs-comment">######################################################################################</span><span class="hljs-comment"># GEOHASH 返回一个或多个位置元素的Geohash表示 如果两个字符串越接近，则距离越近</span>127.0.0.1:6379&gt; GEOHASH china:city guangzhou shenzhen1) <span class="hljs-string">"ws0e9cb3yj0"</span>2) <span class="hljs-string">"ws10k0dcg10"</span></code></pre><h3 id="Hyperloglog-基数统计"><a href="#Hyperloglog-基数统计" class="headerlink" title="Hyperloglog(基数统计)"></a>Hyperloglog(基数统计)</h3><p>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。缺点：0.81%错误率，如果不允许错误使用set类型</p><p>花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。</p><p>因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。其底层使用string数据类型.</p><p>应用场景：网页的访问量（UV）</p><pre><code class="hljs bash">127.0.0.1:6379&gt; PFADD myelemx a b c d e f              <span class="hljs-comment"># 添加指定元素到 HyperLogLog 中</span>(<span class="hljs-built_in">integer</span>) 1127.0.0.1:6379&gt; <span class="hljs-built_in">type</span> myelemx                           <span class="hljs-comment"># hyperloglog底层使用String</span>string127.0.0.1:6379&gt; PFCOUNT myelemx                        <span class="hljs-comment"># 返回给定 HyperLogLog 的基数估算值</span>(<span class="hljs-built_in">integer</span>) 6127.0.0.1:6379&gt; PFADD myelemy e f 1 2 3 4 5(<span class="hljs-built_in">integer</span>) 1127.0.0.1:6379&gt; PFCOUNT myelemy(<span class="hljs-built_in">integer</span>) 7127.0.0.1:6379&gt; PFMERGE myelemz myelemx myelemy        <span class="hljs-comment"># 将多个 HyperLogLog 合并为一个 HyperLogLog</span>OK127.0.0.1:6379&gt; PFCOUNT myelemz                        <span class="hljs-comment"># 合并后估算的基数值</span>(<span class="hljs-built_in">integer</span>) 11</code></pre><h3 id="BitMaps-位图"><a href="#BitMaps-位图" class="headerlink" title="BitMaps(位图)"></a>BitMaps(位图)</h3><p>Bitmap是一串连续的2进制数字（0或1），使用<strong>位存储</strong>，信息状态只有0和1</p><p>场景：用户状态，签到情况等</p><pre><code class="hljs bash">127.0.0.1:6379&gt; SETBIT sign 0 1       <span class="hljs-comment"># 为指定key的offset位设置值</span>(<span class="hljs-built_in">integer</span>) 0127.0.0.1:6379&gt; SETBIT sign 1 1(<span class="hljs-built_in">integer</span>) 0127.0.0.1:6379&gt; SETBIT sign 2 0(<span class="hljs-built_in">integer</span>) 0127.0.0.1:6379&gt; SETBIT sign 3 1(<span class="hljs-built_in">integer</span>) 0127.0.0.1:6379&gt; SETBIT sign 5 1(<span class="hljs-built_in">integer</span>) 0127.0.0.1:6379&gt; <span class="hljs-built_in">type</span> signstring127.0.0.1:6379&gt; GETBIT sign 0         <span class="hljs-comment"># 获取指定offset位的值</span>(<span class="hljs-built_in">integer</span>) 1127.0.0.1:6379&gt; GETBIT sign 2(<span class="hljs-built_in">integer</span>) 0127.0.0.1:6379&gt; GETBIT sign 4(<span class="hljs-built_in">integer</span>) 0127.0.0.1:6379&gt; BITCOUNT sign         <span class="hljs-comment"># 统计字符串被设置为1的bit数</span>(<span class="hljs-built_in">integer</span>) 4</code></pre><h2 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h2><h3 id="Redis事务本质"><a href="#Redis事务本质" class="headerlink" title="Redis事务本质"></a>Redis事务本质</h3><p>Redis事务本质：一组命令的集合，事务中每条命令都会被序列化，执行过程中按顺序执行，不允许其他命令进行干扰。</p><p><strong>一次性、顺序性、排他性</strong></p><p>Redis的单条命令具有原子性，但Redis事务不保证原子性</p><h3 id="Redis事务操作过程"><a href="#Redis事务操作过程" class="headerlink" title="Redis事务操作过程"></a>Redis事务操作过程</h3><ol><li>开启事务（multi）</li><li>命令入队</li><li>执行事务（exec）</li></ol><p>事务中所有命令在加入时都没有被执行，直到提交时才会开始执行(Exec)一次性完成</p><pre><code class="hljs bash">127.0.0.1:6379&gt; multi         <span class="hljs-comment"># 开启事务</span>OK127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> k1 v1     <span class="hljs-comment"># 命令入队</span>QUEUED127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> k2 v2QUEUED127.0.0.1:6379&gt; keys *QUEUED127.0.0.1:6379&gt; get k1QUEUED127.0.0.1:6379&gt; <span class="hljs-built_in">exec</span>          <span class="hljs-comment"># 执行事务</span>1) OK2) OK3) 1) <span class="hljs-string">"k2"</span>   2) <span class="hljs-string">"k1"</span>4) <span class="hljs-string">"v1"</span></code></pre><h3 id="取消事务"><a href="#取消事务" class="headerlink" title="取消事务"></a>取消事务</h3><pre><code class="hljs bash">127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> k1 v1QUEUED127.0.0.1:6379&gt; DISCARD            <span class="hljs-comment"># 取消事务</span>OK127.0.0.1:6379&gt; EXEC               <span class="hljs-comment"># 事务已取消，无法执行</span>(error) ERR EXEC without MULTI     <span class="hljs-comment"># 当前未开启事务</span>127.0.0.1:6379&gt; get k1             <span class="hljs-comment"># 被放弃的事务中命令未执行</span>(nil)</code></pre><h3 id="事务错误"><a href="#事务错误" class="headerlink" title="事务错误"></a>事务错误</h3><ul><li><p>编译时错误：代码语法错误，所有命令都不执行</p><pre><code class="hljs bash">127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> k1 v1QUEUED127.0.0.1:6379&gt; getset k2        <span class="hljs-comment"># 语法错误，报错不影响后续命令入队</span>(error) ERR wrong number of arguments <span class="hljs-keyword">for</span> <span class="hljs-string">'getset'</span> <span class="hljs-built_in">command</span>127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> k3 v3QUEUED127.0.0.1:6379&gt; get k1QUEUED127.0.0.1:6379&gt; <span class="hljs-built_in">exec</span>             <span class="hljs-comment"># 执行报错 </span>(error) EXECABORT Transaction discarded because of previous errors.127.0.0.1:6379&gt; get k1(nil)                            <span class="hljs-comment"># 其他命令未被执行</span></code></pre></li><li><p>运行时错误：代码逻辑错误，其他正常命令正常执行    <strong>（不保证事务原子性）</strong></p><pre><code class="hljs bash">127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> k1 v1QUEUED127.0.0.1:6379&gt; incr k1        <span class="hljs-comment"># 逻辑错误，无法对字符串增量</span>QUEUED127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> k2 v2QUEUED127.0.0.1:6379&gt; get k2QUEUED127.0.0.1:6379&gt; <span class="hljs-built_in">exec</span>1) OK2) (error) ERR value is not an <span class="hljs-built_in">integer</span> or out of range  <span class="hljs-comment"># 运行时报错</span>3) OK4) <span class="hljs-string">"v2"</span>                                                 <span class="hljs-comment"># 不影响后续命令运行</span></code></pre></li></ul><h3 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h3><p>悲观锁：</p><ul><li>认为什么时候都会出现问题，无论什么操作都会加锁</li></ul><p>乐观锁：</p><ul><li>认为什么时候都不会出现问题，所以不会上锁！更新数据的时候去判断一下，在此期间是否有人修改过这个数据</li><li>获取version</li><li>更新的时候比较version</li></ul><p>使用<code>watch</code>监控指定数据，相当于加乐观锁</p><pre><code class="hljs bash">127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> money 100      <span class="hljs-comment"># 设置余额为100</span>OK127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> used 0         <span class="hljs-comment"># 支出为0</span>OK127.0.0.1:6379&gt; watch money        <span class="hljs-comment"># 监视 money 上锁</span>OK127.0.0.1:6379&gt; multi              <span class="hljs-comment"># 开启事务</span>OK127.0.0.1:6379&gt; DECRBY money 10    <span class="hljs-comment"># 余额变动</span>QUEUED127.0.0.1:6379&gt; INCRBY used 10QUEUED127.0.0.1:6379&gt; <span class="hljs-built_in">exec</span>               <span class="hljs-comment"># 监视值没有发生变化，事务执行成功</span>1) (<span class="hljs-built_in">integer</span>) 902) (<span class="hljs-built_in">integer</span>) 10</code></pre><p>模拟另一个线程插队，修改余额</p><pre><code class="hljs bash"><span class="hljs-comment"># 线程1</span>127.0.0.1:6379&gt; watch money       <span class="hljs-comment"># money 上锁</span>OK127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; DECRBY money 15QUEUED127.0.0.1:6379&gt; INCRBY used 15QUEUED127.0.0.1:6379&gt;                   <span class="hljs-comment"># 线程1事务没有执行</span><span class="hljs-comment">######################################################################################</span><span class="hljs-comment"># 线程2</span>127.0.0.1:6379&gt; INCRBY money 100  <span class="hljs-comment"># 此时修改余额</span>(<span class="hljs-built_in">integer</span>) 190<span class="hljs-comment">######################################################################################</span><span class="hljs-comment"># 线程1</span>127.0.0.1:6379&gt; EXEC              <span class="hljs-comment"># 线程2插队后，执行</span>(nil)                             <span class="hljs-comment"># 事务执行失败</span>127.0.0.1:6379&gt; get money         <span class="hljs-comment"># 线程2修改生效</span><span class="hljs-string">"190"</span>127.0.0.1:6379&gt; get used          <span class="hljs-comment"># 线程1事务执行失败，支出发生没有改变</span><span class="hljs-string">"10"</span></code></pre><p>解锁<code>unwatch</code>，再重新加锁执行事务。</p><p>注：每次执行<code>exec</code>后，无论是否成功，都会自动释放锁</p><h2 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h2><h3 id="普通Java项目"><a href="#普通Java项目" class="headerlink" title="普通Java项目"></a>普通Java项目</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestTX</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Jedis jedis = <span class="hljs-keyword">new</span> Jedis(<span class="hljs-string">"xxx.xxx.xxx.xxx"</span>,<span class="hljs-number">6379</span>);        System.out.println(<span class="hljs-string">"flushDB==&gt;"</span>+jedis.flushDB());        JSONObject jsonObject = <span class="hljs-keyword">new</span> JSONObject();        jsonObject.put(<span class="hljs-string">"username"</span>,<span class="hljs-string">"Mike"</span>);        jsonObject.put(<span class="hljs-string">"pwd"</span>,<span class="hljs-string">"123456"</span>);        Transaction multi = jedis.multi();        String string = jsonObject.toString();        <span class="hljs-keyword">try</span> &#123;            multi.set(<span class="hljs-string">"user1"</span>,string);            multi.set(<span class="hljs-string">"user2"</span>,string);            <span class="hljs-comment">// 执行事务</span>            multi.exec();        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            <span class="hljs-comment">// 放弃事务</span>            multi.discard();            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;            System.out.println(jedis.get(<span class="hljs-string">"user1"</span>));            System.out.println(jedis.get(<span class="hljs-string">"user2"</span>));            jedis.close();        &#125;    &#125;&#125;</code></pre><h3 id="整合Spring-Boot"><a href="#整合Spring-Boot" class="headerlink" title="整合Spring Boot"></a>整合Spring Boot</h3><ol><li><p>导入依赖</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></li><li><p>编写配置文件</p><pre><code class="hljs properties"><span class="hljs-comment"># 配置Redis</span><span class="hljs-meta">spring.redis.host</span>=<span class="hljs-string">xxx.xxx.xxx.xxx   # redis ip </span><span class="hljs-meta">spring.redis.port</span>=<span class="hljs-string">6379</span></code></pre></li><li><p>使用RedisTemplate</p><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Redis02SpringbootApplicationTests</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 获取连接对象</span>        RedisConnection connection = redisTemplate.getConnectionFactory().getConnection();        connection.flushDb();        redisTemplate.opsForValue().set(<span class="hljs-string">"k1"</span>,<span class="hljs-string">"v1"</span>);        System.out.println(redisTemplate.opsForValue().get(<span class="hljs-string">"k1"</span>));    &#125;&#125;</code></pre><p>opsForValue() 操作字符串 String</p><p>opsForList 操作List</p></li><li><p>查看测试结果</p><pre><code class="hljs bash">xxx.xxx.xxx.xxx:6379&gt; KEYS *1) <span class="hljs-string">"\xac\xed\x00\x05t\x00\x02k1"</span></code></pre><p>原因：网络中传输的对象需要序列化，否则全是乱码</p></li><li><p>定制RedisTemplate模版</p><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"all"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="hljs-title">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory redisConnectionFactory)</span> <span class="hljs-keyword">throws</span> UnknownHostException </span>&#123;        <span class="hljs-comment">// 将template 泛型设置为 &lt;String, Object&gt;</span>        RedisTemplate&lt;String, Object&gt; template = <span class="hljs-keyword">new</span> RedisTemplate&lt;String, Object&gt;();        <span class="hljs-comment">// 连接工厂，不必修改</span>        template.setConnectionFactory(redisConnectionFactory);        <span class="hljs-comment">/*</span><span class="hljs-comment">         * 序列化设置</span><span class="hljs-comment">         */</span>        <span class="hljs-comment">// Json 序列化配置</span>        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="hljs-keyword">new</span> Jackson2JsonRedisSerializer(Object<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        ObjectMapper om = <span class="hljs-keyword">new</span> ObjectMapper();        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);        jackson2JsonRedisSerializer.setObjectMapper(om);        StringRedisSerializer stringRedisSerializer = <span class="hljs-keyword">new</span> StringRedisSerializer();        <span class="hljs-comment">// key、hash的key 采用 String序列化方式</span>        template.setKeySerializer(stringRedisSerializer);        template.setHashKeySerializer(stringRedisSerializer);        <span class="hljs-comment">// value、hash的value 采用 Jackson 序列化方式</span>        template.setValueSerializer(jackson2JsonRedisSerializer);        template.setHashValueSerializer(jackson2JsonRedisSerializer);        template.afterPropertiesSet();        <span class="hljs-keyword">return</span> template;    &#125;&#125;</code></pre><p>测试</p><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Redis02SpringbootApplicationTests</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params">()</span> </span>&#123;        User liam = <span class="hljs-keyword">new</span> User(<span class="hljs-string">"Liam"</span>, <span class="hljs-string">"123456"</span>);        RedisConnection connection = redisTemplate.getConnectionFactory().getConnection();        connection.flushDb();        redisTemplate.opsForValue().set(<span class="hljs-string">"user"</span>,liam);        System.out.println(redisTemplate.opsForValue().get(<span class="hljs-string">"user"</span>));    &#125;&#125;</code></pre><p>导入RedisUtil工具类</p><p><a href="https://www.cnblogs.com/leeego-123/p/10511856.html" target="_blank" rel="noopener">RedisUtil</a></p></li></ol><h2 id="Redis配置文件-redis-conf"><a href="#Redis配置文件-redis-conf" class="headerlink" title="Redis配置文件 redis.conf"></a>Redis配置文件 redis.conf</h2><ul><li><p>容量单位不区分大小写，G和GB有区别</p><p><img src="https://gitee.com/jiantian99/Images-Hosting/raw/master/img/20200909214627.png" srcset="/img/loading.gif" alt></p></li><li><p>可以使用<code>include</code>包含多个配置文件</p><pre><code class="hljs bash"><span class="hljs-comment"># include /path/to/local.conf</span><span class="hljs-comment"># include /path/to/other.conf</span></code></pre></li><li><p>网络配置   NETWORK</p><pre><code class="hljs bash"><span class="hljs-built_in">bind</span> 127.0.0.1         <span class="hljs-comment"># 绑定的IP         默认是本机</span>protected-mode yes     <span class="hljs-comment"># 是否开启保护模式  默认开启</span>port 6379              <span class="hljs-comment"># redis 端口号     默认6379</span></code></pre></li><li><p>通用          GENERAL</p><pre><code class="hljs bash">daemonize yes           <span class="hljs-comment"># 以守护进程方式运行    默认 no</span>pidfile /var/run/redis_6379.pid   <span class="hljs-comment"># 如果以守护进程方式运行，指定的pid文件</span><span class="hljs-comment"># 日志</span><span class="hljs-comment"># Specify the server verbosity level.</span><span class="hljs-comment"># This can be one of:</span><span class="hljs-comment"># debug模式，记录大量信息，用于开发和测试</span><span class="hljs-comment"># debug (a lot of information, useful for development/testing)     </span><span class="hljs-comment"># verbose模式，记录较多信息，近似于debug</span><span class="hljs-comment"># verbose (many rarely useful info, but not a mess like the debug level)</span><span class="hljs-comment"># notice模式，记录部分重要信息，用于生产环境   默认</span><span class="hljs-comment"># notice (moderately verbose, what you want in production probably)</span><span class="hljs-comment"># warning模式 记录警告等重要信息</span><span class="hljs-comment"># warning (only very important / critical messages are logged)</span>loglevel noticelogfile <span class="hljs-string">""</span>             <span class="hljs-comment"># 日志生成的文件名，默认为空，指标准输出</span>databases 16           <span class="hljs-comment"># Redis数据库数量  默认16</span>always-show-logo yes   <span class="hljs-comment"># 是否显示logo     默认yes</span></code></pre></li><li><p>快照           SNAPSHOTTING</p><pre><code class="hljs bash"><span class="hljs-comment"># 持久化操作</span><span class="hljs-comment"># 900s内，如果有至少1个key发生变化，则进行持久化操作</span>save 900 1<span class="hljs-comment"># 300s内，如果有至少10个key发生变化，则进行持久化操作</span>save 300 10<span class="hljs-comment"># 60s内，如果有至少10000个key发生变化，则进行持久化操作</span>save 60 10000stop-writes-on-bgsave-error yes   <span class="hljs-comment"># 如果持久化失败，是否停止操作     默认为yes</span>rdbcompression yes                <span class="hljs-comment"># rdb文件是否压缩 需要消耗cpu资源  默认为yes</span>rdbchecksum yes                   <span class="hljs-comment"># 保存rdb时，是否进行检查         默认为yes</span>dir ./                            <span class="hljs-comment"># rdb保存路径</span></code></pre></li><li><p>主从复制 REPLICATION </p></li><li><p>安全 SECURITY</p><p>可以修改密码</p></li><li><p>客户端配置 CLIENTS</p><pre><code class="hljs bash"><span class="hljs-comment"># maxclients 10000  最大客户端数</span></code></pre></li><li><p>内存 MEMORY</p><pre><code class="hljs bash"><span class="hljs-comment"># maxmemory &lt;bytes&gt;                 最大内存容量</span><span class="hljs-comment"># maxmemory-policy noeviction       内存满的处理策略</span><span class="hljs-comment"># 1.volatile-lru       只对设置了过期时间的key进行LRU（默认值）</span><span class="hljs-comment"># allkeys-lru          删除lru算法的key</span><span class="hljs-comment"># 3.volatile-random    随机删除即将过期key</span><span class="hljs-comment"># 4.allkeys-random     随机删除</span><span class="hljs-comment"># 5.volatile-ttl       删除即将过期的</span><span class="hljs-comment"># 6.noeviction         永不过期，返回错误</span></code></pre></li><li><p>aof配置  APPEND ONLY MODE</p><pre><code class="hljs bash">appendonly no                     <span class="hljs-comment"># aof是否开启 默认关闭     大部分情况下rdb足够使用</span>appendfilename <span class="hljs-string">"appendonly.aof"</span>   <span class="hljs-comment"># aof持久化文件</span><span class="hljs-comment"># appendfsync always              # 每一次修改</span>appendfsync everysec              <span class="hljs-comment"># 每秒执行一次 sync 可能会失去这一秒的数据</span><span class="hljs-comment"># appendfsync no                  # 不执行同步  此时操作系统执行同步，速度最快</span></code></pre></li></ul><h2 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h2><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><blockquote><p>什么是RDB</p></blockquote><p>RDB：Redis Databases，RDB是Redis用来进行持久化的一种方式，是把当前内存中的数据集快照写入磁盘，也就是 Snapshot 快照（数据库中所有键值对数据）。恢复数据时，直接将快照文件直接读到内存里。默认配置，数据集快照保存到<code>dump.rdb</code>的二进制文件中，文件名可以在Redis配置文件中自定义</p><blockquote><p>工作原理</p></blockquote><p>在进行RDB操作中，Redis主线程不进行IO操作，此时主线程会<code>fork</code>一个子线程来进行RDB。子进程讲数据集写入一个临时的RDB文件中，父进程依旧接收客户端的请求。当子进程完成新的RDB文件写入后，Redis会用该新的RDB文件替换旧的RDB文件。（写时复制机制）</p><blockquote><p>触发机制</p></blockquote><ol><li><p>满足<code>save</code>规则，自动执行RDB机制</p><p>使用<code>save</code>命令时，会立刻对当前内存中的数据进行持久化，但会造成阻塞，占用Redis的主进程，不接受其他操作；如果Redis数据非常多，会造成<code>save</code>命令执行速度慢，影响所有客户端的请求。</p></li><li><p>执行<code>flushall</code>命令，自动执行RDB机制</p></li><li><p>退出redis，自动执行RDB机制</p></li></ol><blockquote><p>触发规则</p></blockquote><p>通过Redis配置文件，进行配置</p><pre><code class="hljs bash"><span class="hljs-comment"># 默认配置</span><span class="hljs-comment"># 900s内，如果有至少1个key发生变化，则进行持久化操作</span>save 900 1<span class="hljs-comment"># 300s内，如果有至少10个key发生变化，则进行持久化操作</span>save 300 10<span class="hljs-comment"># 60s内，如果有至少10000个key发生变化，则进行持久化操作</span>save 60 10000</code></pre><blockquote><p>bgsave</p></blockquote><p><code>bgsave</code>是异步进行同步，当进行RDB操作时，Redis会继续接收其他请求</p><p><code>bgsave</code>与<code>save</code>对比</p><table><thead><tr><th>命令</th><th>save</th><th>bgsave</th></tr></thead><tbody><tr><td>IO类型</td><td>同步</td><td>异步</td></tr><tr><td>是否阻塞</td><td>是</td><td>是（进行fork时，但速度非常快）</td></tr><tr><td>复杂度</td><td>O(n)</td><td>O(n)</td></tr><tr><td>优点</td><td>不消耗额外的内存</td><td>不阻塞客户端</td></tr><tr><td>缺点</td><td>阻塞客户端</td><td>fork子进程需要消耗内存</td></tr></tbody></table><blockquote><p>RDB优缺点</p></blockquote><ul><li><p>优点</p><p>适合大规模的数据恢复</p></li><li><p>缺点</p><ol><li>需要一定的时间间隔进行操作，若Redis进程崩溃，最后一次修改的数据可能消失</li><li>数据的完整性可能不高</li><li>fork子进程时，需要占用一定的内存资源</li></ol></li></ul><h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><blockquote><p>什么是AOF</p></blockquote><p>AOF(Append Only File)，以日志的形式来记录每个写的操作，将Redis执行过的所有指令记录下来（读操作不记录），只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。AOF默认不开启，需要到Redis配置文件中，手动开启</p><blockquote><p>工作原理</p></blockquote><ol><li>所有的命令写入操作追加到AOF缓冲区</li><li>AOF缓冲区根据<code>appendfsync</code>的配置向硬盘进行同步操作</li><li>定期对AOF文件进行重写<ul><li>解决AOF文件越来越大的问题，利用重写机制缩小文件体积。</li><li>重写规则：多条写入命令合并成一条；重写后AOF文件只保留最终数据的写入命令</li><li>手动触发：使用命令<code>bgrewriteaof</code></li><li>自动触发：根据Redis配置规则，如果AOF文件体积大于配置值（默认64M）则触发</li><li>在重写时，主进程继续响应命令，并把写入操作记录写入AOF重写缓冲区，防止数据丢失；子进程创建新的AOF文件来存储重写结果，子进程不能访问在其被创建出来之后产生的新数据。最后父进程将AOF重写缓冲区的数据写入新的AOF文件中然后使用新AOF文件替换老文件。</li></ul></li><li>Redis重启时，自动加载AOF文件进行数据恢复</li></ol><blockquote><p>redis-check-aof –fix</p></blockquote><p>如果AOF文件有错位，Redis无法启动，Redis提供一个工具<code>redis-check-aof --fix</code>修复AOF文件</p><pre><code class="hljs bash">redis-check-aof --fix appendonly.aof</code></pre><blockquote><p>AOF优缺点</p></blockquote><ul><li><p>优点</p><ol><li>每一次修改都同步，数据完整性高</li></ol></li><li><p>缺点</p><ol><li>默认每秒同步一次，可能会丢失这一秒的数据</li><li>相对于RDB，AOF文件体积大，修复效率低，运行效率低</li></ol></li></ul><h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><ol><li>RDB持久化方式能够在指定的时间间隔内对你的数据进行快照存储</li><li>AOF持久化方式记录每次对服务器<strong>写</strong>的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据,AOF命令以Reds协议追加保存每次写的操作到文件末尾, Redis还能对AOF文件进行后台重写,使得AOF文件的体积不至于过大。</li><li>当Redis只做缓存,如果你只希望你的数据在服务器运行的时候存在,你也可以不使用任何持久化</li><li>同时开启两种持久化方式<ul><li>在这种情况下,当 redis重启的时候会优先载入AOF文件来恢复原始的数据,因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集完整</li><li>RDB的数据不实时,同时使用两者时服务器重启也只会找AOF文件,那要不要只使用AOF呢?建议不要,因为RDB更适合用于备份数据库(AOF不断变化不好备份),快速重启,而且不会有AOF可能潜在的Bug,留着作为一个万一的手段。</li></ul></li><li>性能建议<ul><li>因为RDB文件只用作后备用途,建议只在Slave上持久化RDB文件,而且只要15分钟备份一次就够了,只保留<code>save 900 1</code>这条规则。</li><li>如果 Enable AOF,好处是在最恶劣情况下也只会丢失不超过两秒数据,启动脚本较简单只load自己的AOF文件就可以了,代价是带来了持续的IO,二是 AOF rewrite的最后将 rewrite过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可,应该尽量减少 AOF rewrite的频率,AOF重写的基础大小默认值64M太小了,可以设到5G以上,默认超过原大小100%大小重写可以改到适当的数值</li><li>如果不 Enable AOF,仅靠 Master- Slave Repllcation实现高可用性也可以,能省掉一大笔IO,也减少了 rewrite时带来的系统波动。代价是如果 Master/ Slave同时DOWN掉,会丢失十几分钟的数据,启动脚本也要比较两个 Master/ Slave中的RDB文件,载较新的那个,微博就是这种架构。</li></ul></li></ol><h2 id="Redis订阅发布"><a href="#Redis订阅发布" class="headerlink" title="Redis订阅发布"></a>Redis订阅发布</h2><p>Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息</p><p>Redis客户端可以订阅任意数量的频道</p><p><img src="https://www.runoob.com/wp-content/uploads/2014/11/pubsub1.png" srcset="/img/loading.gif" alt="img"></p><p>频道channel1与订阅该频道的三个客户端</p><p><img src="https://gitee.com/jiantian99/Images-Hosting/raw/master/img/20200910121936.png" srcset="/img/loading.gif" alt></p><p>当有新消息通过<code>PUBLISH</code>命令发给频道channel，这条信息会发送给订阅他的三个客户端</p><blockquote><p>原理</p></blockquote><p>每个 Redis 服务器进程都维持着一个表示服务器状态的 redis.h/redisServer 结构， 结构的 pubsub_channels 属性是一个字典，这个字典用于保存订阅频道的信息。字典的键就是一个个正在被订阅的频道，字典的值是一个链表，保存所有订阅该频道的客户端。客户端订阅<code>SUBSCRIBE</code>频道，就被链接到链表尾部，退订<code>UNSUBSCRIBE</code>就从链表中移除该客户端节点。</p><blockquote><p>实例演示</p></blockquote><pre><code class="hljs bash"><span class="hljs-comment"># 客户端</span>127.0.0.1:6379&gt; SUBSCRIBE java                <span class="hljs-comment"># 客户端client订阅了名为 java 的频道</span>Reading messages... (press Ctrl-C to quit)    <span class="hljs-comment"># 等待接收消息</span>1) <span class="hljs-string">"subscribe"</span>                                <span class="hljs-comment"># 订阅成功</span>2) <span class="hljs-string">"java"</span>3) (<span class="hljs-built_in">integer</span>) 1<span class="hljs-comment"># 发布端</span>127.0.0.1:6379&gt; PUBLISH java <span class="hljs-string">"Hello world"</span>    <span class="hljs-comment"># 发生消息到 java 频道</span>(<span class="hljs-built_in">integer</span>) 1127.0.0.1:6379&gt; PUBLISH java <span class="hljs-string">"Thank you for subscribing to my channel"</span>(<span class="hljs-built_in">integer</span>) 1<span class="hljs-comment"># 客户端</span>1) <span class="hljs-string">"message"</span>                                   <span class="hljs-comment"># 接收到来自频道 java 的信息 "Hello world"</span>2) <span class="hljs-string">"java"</span>3) <span class="hljs-string">"Hello world"</span>1) <span class="hljs-string">"message"</span>2) <span class="hljs-string">"java"</span>3) <span class="hljs-string">"Thank you for subscribing to my channel"</span></code></pre><blockquote><p>使用场景</p></blockquote><ol><li>实时消息系统</li><li>实时多人聊天</li><li>订阅、关注系统</li></ol><p>稍微复杂的场景，使用消息中间键MQ处理</p><blockquote><p>缺点</p></blockquote><ol><li>如果客户端订阅了频道，但读取消息速度不够快，会使订阅消息产生堆积，Redis输出缓冲区的体积变大，影响Redis的速度</li><li>数据传输可靠性不高，如果客户端掉线，就接收不到断线期间发布者发布的消息</li></ol><h2 id="Redis集群化处理"><a href="#Redis集群化处理" class="headerlink" title="Redis集群化处理"></a>Redis集群化处理</h2><blockquote><p>作用</p></blockquote><ol><li><p>数据冗余</p><p>主从复制实现了数据的热备份，是持久化之外的一种数据冗余的方式</p></li><li><p>故障恢复</p><p>当主节点故障时，从节点可以暂时替代主节点提供服务，是一种服务冗余的方式</p></li><li><p>负载均衡</p><p>在主从复制的基础上，配合读写分离，由主节点进行写操作，从节点进行读操作，分担服务器的负载；尤其是在多读少写的场景下，通过多个从节点分担负载，提高并发量</p></li><li><p>高可用基石</p><p>主从复制还是哨兵和集群能够实施的基础</p></li></ol><h3 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h3><blockquote><p>概念</p></blockquote><p>主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点（Master）,后者称为从节点（Slave），数据的复制是<strong>单向</strong>的，只能从主节点复制到从节点，主节点写为主，从节点读为主。</p><p>默认情况下，每台Redis服务器都是主节点，一个主节点可以拥有0~N个从节点，但每个从节点只能有一个主节点。</p><p>在工程项目中，使用集群很有必要，原因：</p><ol><li>从容量上，单台服务器内存容量有限，难以负载大量的请求</li><li>从结构上，只使用单台服务器，单点故障概率高、系统崩溃概率大</li></ol><blockquote><p>原理</p></blockquote><ul><li>从服务器发送SYNC命令，连接主服务器</li><li>主服务器收到SYNC命令后，执行bgsave命令生成RDB文件，并使用缓冲区记录此后所有写命令</li><li>主服务器bgsave执行完成后，向所有从服务器发送快照文件。发送期间，继续记录所有写命令</li><li>从服务器收到快照文件后，丢弃原有旧数据，载入新收到的快照</li><li>主服务器发送完快照文件后，向数据库写入缓冲区中的所有写命令</li><li>从服务器完成快照的载入后（从数据库初始化完成），开始接收命令的请求，同时执行来自主服务器缓冲区的写命令</li><li>每当主服务器执行一次写命令，就会向从服务器发送相同的写命令，从服务器接收并执行该写命令</li><li>当从服务器出现断线重连后，主服务器会将断线期间的命令发送给从服务器，进行增量复制</li><li>主从服务器刚刚建立连接时，会进行全量同步；全量同步结束后，进行增量同步。若有需要，从服务器可随时进行全量同步。Redis策略：优先进行增量同步，增量同步失败再进行全量同步</li></ul><blockquote><p>配置</p></blockquote><p>Redis配置文件需修改端口号、pid文件名、日志文件名、rdb文件名</p><blockquote><p>优缺点</p></blockquote><ul><li>优点<ul><li>支持主从复制，主机会自动将数据同步到从机，可以进行读写分离，分载主机的读操作压力，从机可以为客户端提供只读操作的服务，写操作仍然必须由主机来完成</li><li>Slave同样可以接受其它Slaves的连接和同步请求，这样可以有效的分载Master的同步压力</li><li>Master Server是以非阻塞的方式为Slaves提供服务。所以在Master-Slave同步期间，客户端仍然可以提交查询或修改请求；Slave Server同样是以非阻塞的方式完成数据同步。在同步期间，如果有客户端提交查询请求，Redis则返回同步之前的数据</li></ul></li><li>缺点<ul><li>Redis不具备自动容错和恢复功能，主机从机的宕机都会导致客户端读写请求失败，需要等待机器重启或者手动切换IP才能恢复</li><li>当主机宕机，宕机前有部分数据未同步到从机，客户端只能连接从机完成读操作</li><li>如果多个从机宕机断线，多个从机重连的时候，造成主机IO剧增</li><li>难于实现在线扩容</li></ul></li></ul><h3 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h3><p>主从复制的模式，当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。这不是一种推荐的方式，更多时候，我们优先考虑哨兵模式。</p><p>哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独立运行。其原理是哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例。</p><blockquote><p>作用</p></blockquote><ol><li>发送命令，让Redis服务器返回监控其运行状态，包括主、从服务器</li><li>当哨兵检测到主服务器宕机，会自动选举一个从机当选主机，并通过发布订阅模式通知其他从机，修改配置文件，让其他从机切换主机</li></ol><blockquote><p>工作模式</p></blockquote><ul><li>每个哨兵进程都以每秒一次的频率向整个集群的主服务器、从服务器及其他哨兵进程发送一个PING命令</li><li>如果有一个实例距离最后一次有效回复PING命令的时间超过了<code>down-after-milliseconds</code>设定的值（默认30s），则这个实例会被哨兵标记为<em>主观下线</em></li><li>如果一个主服务器被标记为主观下线，则正在监视这个主服务器的所有哨兵都要以每秒一次的频率确认主服务器是否是主观下线状态</li><li>当有足够数量（设定quorum值）的哨兵在指定的时间范围内确认主服务器进入主观下线状态，则主服务器被标记为<em>客观下线</em></li><li>一般情况下，哨兵会以10秒一次的频率向集群中所有主从服务器发送INFO命令</li><li>当主服务器被标记为客观下线时，哨兵会以每秒一次的频率向所有从服务器发送INFO命令</li><li>若没有足够数量哨兵认为主服务器下线，主服务器的客观下线状态会被移除；若主服务器重新向哨兵发送PING命令返回有效回复，主服务器的主观下线状态也被移除</li><li>当原主服务器重新上线后，自动转为现主服务器的从节点</li></ul><blockquote><p>故障切换过程</p></blockquote><p>当主服务器宕机，哨兵1先检测这个结果，但不会立刻进行故障切换，仅仅是哨兵1主观认为主服务器不可用，这种现象称为<strong>主观下线</strong>。当其他哨兵也检测到主服务器不可用时，并且已发现的哨兵数量达到一定值，哨兵之间会进行一次投票，投票结果由一个哨兵发起，进行故障切换操作。切换成功后，通过发布订阅模式，让各个哨兵把自己监控的从服务器切换主服务器，这个过程称为<strong>客观下线</strong>。</p><blockquote><p>哨兵模式配置文件 sentinel.conf</p></blockquote><p>自定义哨兵配置文件，不加入配置命令，表明使用默认配置</p><pre><code class="hljs bash"><span class="hljs-comment"># 哨兵sentinel实例运行的端口 默认26379</span>port 26379 <span class="hljs-comment"># 哨兵sentinel的工作目录</span>dir /tmp <span class="hljs-comment"># 哨兵sentinel监控的redis主节点的 ip port </span><span class="hljs-comment"># master-name  自定义命名的主节点名字 只能由字母A-z、数字0-9 、这三个字符".-_"组成。</span><span class="hljs-comment"># quorum 当有quorum个sentinel哨兵认为master主节点失联 那么这时 客观上认为主节点失联了</span><span class="hljs-comment"># sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</span>sentinel monitor mymaster 127.0.0.1 6379 1 <span class="hljs-comment"># 当在Redis实例中开启了requirepass foobared 授权密码 这样所有连接Redis实例的客户端都要提供密码</span><span class="hljs-comment"># 设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码</span><span class="hljs-comment"># sentinel auth-pass &lt;master-name&gt; &lt;password&gt;</span>sentinel auth-pass mymaster password  <span class="hljs-comment"># 指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认30秒</span><span class="hljs-comment"># sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;</span>sentinel down-after-milliseconds mymaster 30000 <span class="hljs-comment"># 这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步，</span><span class="hljs-comment"># 这个数字越小，完成failover所需的时间就越长，</span><span class="hljs-comment"># 但如果这个数字越大，就意味着越多的slave因为replication而不可用。</span><span class="hljs-comment"># 可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。</span><span class="hljs-comment"># sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt;</span>sentinel parallel-syncs mymaster 1   <span class="hljs-comment"># 故障转移的超时时间 failover-timeout 可以用在以下这些方面： </span><span class="hljs-comment">#1. 同一个sentinel对同一个master两次failover之间的间隔时间。</span><span class="hljs-comment">#2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时。</span><span class="hljs-comment">#3. 当想要取消一个正在进行的failover所需要的时间。  </span><span class="hljs-comment">#4. 当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了</span><span class="hljs-comment"># 默认三分钟</span><span class="hljs-comment"># sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;</span>sentinel failover-timeout mymaster 180000 <span class="hljs-comment"># SCRIPTS EXECUTION</span> <span class="hljs-comment">#配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知相关人员。</span><span class="hljs-comment">#对于脚本的运行结果有以下规则：</span><span class="hljs-comment">#若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10</span><span class="hljs-comment">#若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行。</span><span class="hljs-comment">#如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同。</span><span class="hljs-comment">#一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。</span> <span class="hljs-comment">#通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等），将会去调用这个脚本，</span><span class="hljs-comment">#这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信息。调用该脚本时，将传给脚本两个参数，</span><span class="hljs-comment">#一个是事件的类型，</span><span class="hljs-comment">#一个是事件的描述。</span><span class="hljs-comment">#如果sentinel.conf配置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无法正常启动成功。</span><span class="hljs-comment">#通知脚本</span><span class="hljs-comment"># sentinel notification-script &lt;master-name&gt; &lt;script-path&gt;</span>  sentinel notification-script mymaster /var/redis/notify.sh <span class="hljs-comment"># 客户端重新配置主节点参数脚本</span><span class="hljs-comment"># 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已经发生改变的信息。</span><span class="hljs-comment"># 以下参数将会在调用脚本时传给脚本:</span><span class="hljs-comment"># &lt;master-name&gt; &lt;role&gt; &lt;state&gt; &lt;from-ip&gt; &lt;from-port&gt; &lt;to-ip&gt; &lt;to-port&gt;</span><span class="hljs-comment"># 目前&lt;state&gt;总是“failover”,</span><span class="hljs-comment"># &lt;role&gt;是“leader”或者“observer”中的一个。 </span><span class="hljs-comment"># 参数 from-ip, from-port, to-ip, to-port是用来和旧的master和新的master(即旧的slave)通信的</span><span class="hljs-comment"># 这个脚本应该是通用的，能被多次调用，不是针对性的。</span><span class="hljs-comment"># sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt;</span>sentinel client-reconfig-script mymaster /var/redis/reconfig.sh</code></pre><blockquote><p>优缺点</p></blockquote><ul><li><p>优点</p><ol><li>哨兵模式基于主从复制，具备主从复制的所有优点</li><li>主从可以实现自动切换，系统更健壮，可用性更好</li></ol></li><li><p>缺点</p><p>难于实现在线扩容，一旦集群数量达到上限，在线扩容麻烦</p></li></ul><h3 id="集群-Cluster"><a href="#集群-Cluster" class="headerlink" title="集群 Cluster"></a>集群 Cluster</h3><p>Redis 的哨兵模式基本已经可以实现高可用，读写分离 ，但是在这种模式下每台 Redis 服务器都存储相同的数据，很浪费内存，在Redis3.0上加入了 Cluster 集群模式，实现了 Redis 的分布式存储，也就是说每台 Redis 节点上存储不同的内容。</p><p>官方推荐，集群部署至少要 3 台以上的master节点，最好使用 3 主 3 从六个节点的模式</p><blockquote><p>特点</p></blockquote><ul><li>所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽</li><li>节点的fail是通过集群中超过半数的节点检测失效时才生效</li><li>客户端与 Redis 节点直连,不需要中间代理层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可。</li></ul><blockquote><p>工作方式</p></blockquote><p>　　在 Redis 的每一个节点上，都有这么两个东西，一个是插槽（slot），它的的取值范围是：0-16383。还有一个就是cluster，可以理解为是一个集群管理的插件。当我们的存取的 Key到达的时候，Redis 会根据 crc16的算法得出一个结果，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，通过这个值，去找到对应的插槽所对应的节点，然后直接自动跳转到这个对应的节点上进行存取操作。</p><p>　　为了保证高可用，redis-cluster集群引入了主从模式，一个主节点对应一个或者多个从节点，当主节点宕机的时候，就会启用从节点。当其它主节点ping一个主节点A时，如果半数以上的主节点与A通信超时，那么认为主节点A宕机了。如果主节点A和它的从节点A1都宕机了，那么该集群就无法再提供服务了。</p><blockquote><p> 优缺点</p></blockquote><ul><li><p>优点</p><ol><li>采用P2P模式，无中心架构</li><li>数据按照slot插槽分布在多个节点，节点间数据共享，可动态调整数据分布</li><li>可拓展，节点可动态添加或删除</li><li>高可用，部分节点不可用时，集群可继续使用</li></ol></li><li><p>缺点</p><ol><li>不能使用mset、mget等批量操作</li><li>不支持多数据库，Redis默认支持16个数据库，集群模式只支持1个数据库空间</li><li>数据通过异步复制，不保证数据的强一致性</li></ol></li></ul><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><blockquote><p>概念</p></blockquote><p>在默认情况下，用户请求数据时，会先在缓存(Redis)中查找，若没找到即缓存未命中，再去持久层数据库中进行查找，数量少可能问题不大，可是一旦大量的请求数据（例如秒杀场景）缓存都没有命中的话，就会全部转移到数据库上，造成数据库极大的压力，就有可能导致数据库崩溃。网络安全中也有人恶意使用这种手段进行攻击被称为洪水攻击。</p><blockquote><p>解决方案</p></blockquote><ol><li><p>布隆过滤器</p><ul><li>布隆过滤器是一个BIT数组，本质上是一个数据，可以根据下标快速找到数据</li><li>哈希映射<ul><li>布隆过滤器通过Hash函数对需要记录的数据进行Hash操作，得到的数组下标在BIT数组中记录值为1</li><li>需要判断某一数据是否存在时，布隆过滤器对该数据进行Hash，得到下标，如果该下标在数组中值为1说明数据存在，为0说明不存在</li></ul></li><li>布隆过滤器存在精准度问题，如果数组过于拥挤，不同的数据可能Hash同一个下标数据，因此布隆过滤器只能判断数据<strong>可能存在</strong>和<strong>一定不存在</strong></li><li>布隆过滤器不支持删除，因此只能保证数据一定不存在</li></ul><p><img src="https://gitee.com/jiantian99/Images-Hosting/raw/master/img/20200911101008.png" srcset="/img/loading.gif" alt></p></li><li><p>缓存空对象</p><ul><li>一次请求若在缓存和数据库中都没找到，则将持久层返回的空对象缓存起来，同时设置过期时间，用于处理后续这个请求，此后再访问这个数据，直接从缓存中获取，保护了持久层数据库</li><li>存在问题：<ol><li>把空值缓存起来，占用内存空间</li><li>设置了空对象的过期时间，会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响</li></ol></li></ul></li></ol><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><blockquote><p>概念</p></blockquote><p>一个存在的key（热点数据），在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到DB，造成瞬时DB请求量大、压力骤增。这就是缓存被击穿，只是针对其中某个key的缓存不可用而导致击穿，但是其他的key依然可以使用缓存响应。</p><blockquote><p>解决方案</p></blockquote><ol><li><p>设置热点数据永不过期</p><p>如果热点数据过多，会长期占用Redis内存</p></li><li><p>加互斥锁（分布式锁）</p><p>保证同时刻只有一个线程访问DB</p></li></ol><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><blockquote><p>概念</p></blockquote><p>缓存层出现了错误，集中在一段时间内失效，不能正常工作了。于是所有的请求都会达到存储层，发生大量的缓存穿透，存储层的调用量会暴增，造成存储层也会挂掉的情况</p><blockquote><p>解决方案</p></blockquote><ol><li><p>Redis高可用</p><p>搭建Redis集群，保证Redis的高可用性</p></li><li><p>限流降级</p><p>在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待</p></li><li><p>数据预热</p><p>在正式部署之前，先把可能的数据先预访问一遍，部分预计大量访问的数据就会加载到缓存中；在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀</p></li></ol><p>参考资料</p><ol><li><a href="https://www.bilibili.com/video/BV1S54y1R7SB" target="_blank" rel="noopener">狂神说Java</a></li><li><a href="https://www.cnblogs.com/leeego-123/p/10511856.html" target="_blank" rel="noopener">SpringBoot整合Redis及Redis工具类撰写</a></li><li><a href="https://www.jianshu.com/p/06ab9daf921d" target="_blank" rel="noopener">哨兵模式</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2020-08 踩坑记录</title>
    <link href="/2020/08/26/2020-08%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    <url>/2020/08/26/2020-08%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="Component-template-should-contain-exactly-one-root-element-If-you-are-using-v-if-on-multiple-elements-use-v-else-if-to-chain-them-instead"><a href="#Component-template-should-contain-exactly-one-root-element-If-you-are-using-v-if-on-multiple-elements-use-v-else-if-to-chain-them-instead" class="headerlink" title="Component template should contain exactly one root element. If you are using v-if on multiple elements, use v-else-if to chain them instead"></a>Component template should contain exactly one root element. If you are using v-if on multiple elements, use v-else-if to chain them instead</h2><p>vue模板<code>&lt;template&gt;</code>只能有一个根对象，使用一个<code>&lt;div&gt;</code>包裹所有元素即可解决</p><h2 id="在Centos8系统编译Mysql5-7-27时-出现依赖包不全的情况报错"><a href="#在Centos8系统编译Mysql5-7-27时-出现依赖包不全的情况报错" class="headerlink" title="在Centos8系统编译Mysql5.7.27时,出现依赖包不全的情况报错"></a>在Centos8系统编译Mysql5.7.27时,出现依赖包不全的情况报错</h2><p>安装所需依赖包，并重新预编译。重新预编译前，需要删除”CMakeCache.txt”文件</p><h3 id="Package-‘libtirpc‘-required-by-‘virtual-world‘-not-found"><a href="#Package-‘libtirpc‘-required-by-‘virtual-world‘-not-found" class="headerlink" title="Package ‘libtirpc‘, required by ‘virtual:world‘, not found"></a>Package ‘libtirpc‘, required by ‘virtual:world‘, not found</h3><p>报错内容：</p><pre><code class="hljs groovy">-- Checking <span class="hljs-keyword">for</span> module ‘libtirpc‘--   Package ‘libtirpc‘, required by ‘<span class="hljs-string">virtual:</span>world‘, not foundCMake Error at cmake/rpc.<span class="hljs-string">cmake:</span><span class="hljs-number">65</span> (MESSAGE):  Could not find rpc<span class="hljs-regexp">/rpc.h in /</span>usr<span class="hljs-regexp">/include or /</span>usr<span class="hljs-regexp">/include/</span>tirpcCall Stack (most recent call first):  plugin<span class="hljs-regexp">/group_replication/</span>libmysqlgcs/configure.<span class="hljs-string">cmake:</span><span class="hljs-number">57</span> (MYSQL_CHECK_RPC)  plugin<span class="hljs-regexp">/group_replication/</span>libmysqlgcs/CMakeLists.<span class="hljs-string">txt:</span><span class="hljs-number">28</span> (INCLUDE)</code></pre><p>解决方法：</p><pre><code class="hljs cmake">yum <span class="hljs-keyword">install</span> -y libtirpc-devel</code></pre><h3 id="Could-not-find-rpcgen"><a href="#Could-not-find-rpcgen" class="headerlink" title="Could not find rpcgen"></a>Could not find rpcgen</h3><p>报错内容：</p><pre><code class="hljs less"><span class="hljs-selector-tag">CMake</span> <span class="hljs-selector-tag">Error</span> <span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">rapid</span>/<span class="hljs-selector-tag">plugin</span>/<span class="hljs-selector-tag">group_replication</span>/<span class="hljs-selector-tag">rpcgen</span><span class="hljs-selector-class">.cmake</span><span class="hljs-selector-pseudo">:93</span> (MESSAGE):  <span class="hljs-selector-tag">Could</span> <span class="hljs-selector-tag">not</span> <span class="hljs-selector-tag">find</span> <span class="hljs-selector-tag">rpcgen</span><span class="hljs-selector-tag">Call</span> <span class="hljs-selector-tag">Stack</span> (most recent call first):  <span class="hljs-selector-tag">rapid</span>/<span class="hljs-selector-tag">plugin</span>/<span class="hljs-selector-tag">group_replication</span>/<span class="hljs-selector-tag">CMakeLists</span><span class="hljs-selector-class">.txt</span><span class="hljs-selector-pseudo">:29</span> (INCLUDE)</code></pre><p>解决方法：</p><pre><code class="hljs vim">wget http<span class="hljs-variable">s:</span>//github.<span class="hljs-keyword">com</span>/thkukuk/rpcsvc-proto/releases/download/v1.<span class="hljs-number">4</span>/rpcsvc-proto-<span class="hljs-number">1.4</span>.tar.gztar xf rpcsvc-proto-<span class="hljs-number">1.4</span>.tar.gz<span class="hljs-keyword">cd</span> rpcsvc-proto-<span class="hljs-number">1.4</span>./configure<span class="hljs-keyword">make</span><span class="hljs-keyword">make</span> install</code></pre><h2 id="Spring-Boot-设置拦截器，报空指针异常"><a href="#Spring-Boot-设置拦截器，报空指针异常" class="headerlink" title="Spring Boot 设置拦截器，报空指针异常"></a>Spring Boot 设置拦截器，报空指针异常</h2><p>报错内容：在登录拦截器中，redisPool报了空指针异常</p><pre><code class="hljs yaml"><span class="hljs-attr">java.lang.NullPointerException:</span> <span class="hljs-literal">null</span></code></pre><pre><code class="hljs java"><span class="hljs-comment">// 错误的方法</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> </span>&#123;    <span class="hljs-comment">// 增加登录拦截器</span>    registry.addInterceptor(<span class="hljs-keyword">new</span> LoginHandlerInterceptor()).addPathPatterns(<span class="hljs-string">"/obs/**"</span>);&#125;</code></pre><p>分析：在配置登录拦截器时，使用了new 对象的方法，正确方式应该是使用Spring的依赖注入，让Spring容器帮我去new一个登录拦截器对象，并检查所需的依赖，自动装配。</p><p>解决方法：</p><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span>LoginHandlerInterceptor loginHandlerInterceptor;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> </span>&#123;    <span class="hljs-comment">// 增加登录拦截器</span>    registry.addInterceptor(loginHandlerInterceptor).addPathPatterns(<span class="hljs-string">"/obs/**"</span>);&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>日常记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>踩坑记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue路由</title>
    <link href="/2020/08/13/Vue%E8%B7%AF%E7%94%B1/"/>
    <url>/2020/08/13/Vue%E8%B7%AF%E7%94%B1/</url>
    
    <content type="html"><![CDATA[<h2 id="Vue-Router"><a href="#Vue-Router" class="headerlink" title="Vue Router"></a>Vue Router</h2><p>Vue Router是Vue.js官方的<strong>路由管理器</strong>（路径跳转）。它和Vue.js的核心深度集成，让构建单页面应用变得易如反掌。包含的功能有:</p><ol><li>嵌套的路由/视图表</li><li>模块化的、基于组件的路由配置</li><li>路由参数、查询、通配符</li><li>基于Vue.js过渡系统的视图过渡效果</li><li>细粒度的导航控制</li><li>带有自动激活的CSS class的链接</li><li>HTML5历史模式或hash模式，在IE9中自动降级</li><li>自定义的滚动条行为</li></ol><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code class="hljs q">npm install vue-router --<span class="hljs-built_in">save</span>-<span class="hljs-built_in">dev</span></code></pre><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>index.html调用main.js，再调用App.vue</p><p>index.html</p><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Vue<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><p>main.js</p><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span><span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">'./App'</span><span class="hljs-comment">// 自动扫描路由配置</span><span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">'./router'</span>Vue.config.productionTip = <span class="hljs-literal">false</span><span class="hljs-comment">/* eslint-disable no-new */</span><span class="hljs-keyword">new</span> Vue(&#123;  el: <span class="hljs-string">'#app'</span>,  <span class="hljs-comment">// 配置路由</span>  router,  components: &#123; App &#125;,  template: <span class="hljs-string">'&lt;App/&gt;'</span>&#125;)</code></pre><p>App.vue</p><ul><li>使用<code>&lt;router-link&gt;</code>组件来导航，传入<code>to</code>属性指定链接，<code>&lt;router-link&gt;</code>默认渲染成一个<code>&lt;a&gt;</code>标签</li><li><code>&lt;router-view&gt;</code>是路由出口，路由匹配到的组件渲染到此处</li></ul><pre><code class="hljs vue">&lt;template&gt;  &lt;div id&#x3D;&quot;app&quot;&gt;    &lt;h1&gt;使用Vue Router&lt;&#x2F;h1&gt;    &lt;router-link to&#x3D;&quot;&#x2F;test&quot;&gt;Test&lt;&#x2F;router-link&gt;    &lt;router-link to&#x3D;&quot;&#x2F;main&quot;&gt;Main&lt;&#x2F;router-link&gt;    &lt;router-link to&#x3D;&quot;&#x2F;foo&quot;&gt;Foo&lt;&#x2F;router-link&gt;    &lt;router-view&gt;&lt;&#x2F;router-view&gt;  &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123;  name: &#39;App&#39;,&#125;&lt;&#x2F;script&gt;&lt;style&gt;#app &#123;  font-family: &#39;Avenir&#39;, Helvetica, Arial, sans-serif;  -webkit-font-smoothing: antialiased;  -moz-osx-font-smoothing: grayscale;  text-align: center;  color: #2c3e50;  margin-top: 60px;&#125;&lt;&#x2F;style&gt;</code></pre><p>路由配置 index.js (默认路由配置文件名)</p><pre><code class="hljs javascript"><span class="hljs-comment">// 导入Vue和VueRouter</span><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span><span class="hljs-keyword">import</span> VueRouter <span class="hljs-keyword">from</span> <span class="hljs-string">"vue-router"</span>;<span class="hljs-comment">// 导入组件</span><span class="hljs-keyword">import</span> Test <span class="hljs-keyword">from</span> <span class="hljs-string">"../components/Test"</span>;<span class="hljs-keyword">import</span> Main <span class="hljs-keyword">from</span> <span class="hljs-string">"../components/Main"</span>;<span class="hljs-keyword">import</span> Foo <span class="hljs-keyword">from</span> <span class="hljs-string">"../components/Foo"</span>;<span class="hljs-comment">// 安装路由</span>Vue.use(VueRouter)<span class="hljs-comment">// 配置导出路由</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> VueRouter(&#123;  routes:[    <span class="hljs-comment">// Test 组件</span>    &#123;      <span class="hljs-comment">// 路由的路径</span>      path: <span class="hljs-string">'/test'</span>,      name: <span class="hljs-string">'content'</span>,      <span class="hljs-comment">// 跳转的组件</span>      component: Test    &#125;,    &#123;      <span class="hljs-comment">// 路由的路径</span>      path: <span class="hljs-string">'/main'</span>,      name: <span class="hljs-string">'content'</span>,      <span class="hljs-comment">// 跳转的组件</span>      component: Main    &#125;,    &#123;      <span class="hljs-comment">// 路由的路径</span>      path: <span class="hljs-string">'/foo'</span>,      <span class="hljs-comment">// name: 'content',</span>      <span class="hljs-comment">// 跳转的组件</span>      component: Foo    &#125;,  ]&#125;)</code></pre><p>Test.vue中使用路由</p><pre><code class="hljs vue">&lt;template&gt;    &lt;div&gt;&lt;h1&gt;This is Test&lt;&#x2F;h1&gt;&lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;    export default &#123;        name: &quot;Test&quot;    &#125;&lt;&#x2F;script&gt;&lt;style scoped&gt;&lt;&#x2F;style&gt;</code></pre><p>启动测试</p><pre><code class="hljs dockerfile">npm <span class="hljs-keyword">run</span><span class="bash"> dev</span></code></pre><h2 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h2><p>嵌套路由又称子路由，在实际应用中，通常由多层嵌套的组件组合而成。同样地，URL 中各段动态路径也按某种结构对应嵌套的各层组件，例如：</p><pre><code class="hljs routeros">/user/foo<span class="hljs-built_in">/profile </span>                    /user/foo/posts+------------------+                  +-----------------+|<span class="hljs-built_in"> User </span>            |                  |<span class="hljs-built_in"> User </span>           || +--------------+ |                  | +-------------+ || |<span class="hljs-built_in"> Profile </span>     | |  +------------&gt;  | | Lists       | || |              | |                  | |             | || +--------------+ |                  | +-------------+ |+------------------+                  +-----------------+</code></pre><p>在<code>VueRouter</code>参数中使用<code>children</code>配置嵌套路由</p><pre><code class="hljs js">routes:[    &#123;      path: <span class="hljs-string">'/main'</span>,      component: Main,      <span class="hljs-comment">// 导入子模块</span>      children:[        &#123;          path: <span class="hljs-string">'/user/profile'</span>,          component: UserProfile,        &#125;,&#123;          path: <span class="hljs-string">'/user/list'</span>,          component: UserList,        &#125;      ]    &#125;]</code></pre><h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p>当请求时，需要传递参数</p><ul><li><p>第一种取值方式，使用<code>$route.params</code></p><ol><li><p>修改路由配置<code>index.js</code></p><pre><code class="hljs js">&#123;    path: <span class="hljs-string">'/user/profile/:id'</span>,    name: <span class="hljs-string">'UserProfile'</span>,    component: UserProfile,&#125;</code></pre></li><li><p>在<code>&lt;route-link&gt;</code>处改成<code>:to</code>，将这一属性当作对象来使用，<code>&lt;route-link&gt;</code>中的<code>name</code>要与路由配置中的<code>name</code>匹配</p><pre><code class="hljs vue">&lt;router-link :to&#x3D;&quot;&#123;name:&#39;UserProfile&#39;,params:&#123;id:1&#125;&#125;&quot;&gt;个人信息&lt;&#x2F;router-link&gt;</code></pre></li><li><p>在展示的组件<code>Profile.vue</code>中接收参数</p><pre><code class="hljs vue">&#123;&#123;$route.params.id&#125;&#125;</code></pre></li></ol></li><li><p>第二种取值方式，使用<code>props</code>减少耦合</p><ol><li><p>路由配置<code>index.js</code>中增加<code>props: true</code>属性</p><pre><code class="hljs js">&#123;    path: <span class="hljs-string">'/user/profile/:id'</span>,    name: <span class="hljs-string">'UserProfile'</span>,    component: UserProfile,    props: <span class="hljs-literal">true</span>&#125;</code></pre></li><li><p>在展示的组件<code>Profile.vue</code>中接收参数，增加<code>props</code>参数</p><pre><code class="hljs vue">&lt;template&gt;  &lt;div&gt;    &lt;h1&gt;个人信息&lt;&#x2F;h1&gt;    &#123;&#123;id&#125;&#125;  &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;  export default &#123;    props: [&#39;id&#39;],    name: &quot;UserProfile&quot;  &#125;&lt;&#x2F;script&gt;</code></pre></li></ol></li></ul><h2 id="重定向和别名"><a href="#重定向和别名" class="headerlink" title="重定向和别名"></a>重定向和别名</h2><p>重定向也是通过 <code>routes</code>路由 配置来完成</p><ul><li><p>从<code>/goHome</code>到<code>/main</code></p><pre><code class="hljs js">&#123;    path: <span class="hljs-string">'/goHome'</span>,redirect: <span class="hljs-string">'/main'</span>&#125;</code></pre></li><li><p>重定向的目标也可以是一个有命名的路由</p><pre><code class="hljs js">&#123;path: <span class="hljs-string">'/goHome'</span>,redirect: &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">'main'</span>&#125;&#125;</code></pre></li></ul><p>重定向指的是：访问<code>/goHome</code>，url替换成<code>/main</code>，路由匹配的是<code>/main</code></p><p>别名指的是：<code>/main</code>的别名是<code>/goHome</code>，访问<code>/goHome</code>时，url保持<code>/goHome</code>，但路由匹配的是<code>/main</code>，就像直接访问<code>/main</code>一样</p><pre><code class="hljs js">&#123;path: <span class="hljs-string">'/main'</span>,name: <span class="hljs-string">'main'</span>,    component: Main,    alias: <span class="hljs-string">'/goHome'</span>,&#125;</code></pre><h2 id="路由模式"><a href="#路由模式" class="headerlink" title="路由模式"></a>路由模式</h2><ul><li>hash：路径带 # 符号（默认），如 <a href="http://localhost/#/login" target="_blank" rel="noopener">http://localhost/#/login</a> </li><li>history：路径不带 # 符号，如 <a href="http://localhost/login" target="_blank" rel="noopener">http://localhost/login</a></li></ul><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> VueRouter(&#123;    mode: <span class="hljs-string">'history'</span>,    routes: [    ]&#125;);</code></pre><h2 id="404"><a href="#404" class="headerlink" title="404"></a>404</h2><p>使用通配符<code>*</code>，并放在路由配置的最后</p><pre><code class="hljs js">&#123;    path: <span class="hljs-string">'*'</span>,    component: NotFound&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue，前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue基础语法</title>
    <link href="/2020/08/11/Vue%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <url>/2020/08/11/Vue%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h2><p>使用<code>v-bind</code>，将这个元素节点的 <code>title</code>  和 Vue 实例的 <code>message</code> property 保持一致</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"vue"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-bind:title</span>=<span class="hljs-string">"message"</span>&gt;</span>鼠标悬停几秒钟查看此处动态绑定的提示信息！<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;    el: <span class="hljs-string">'#vue'</span>,    data: &#123;        message: <span class="hljs-string">'hello vue'</span>    &#125;&#125;);</code></pre><p>缩写：</p><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 完整语法 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">v-bind:href</span>=<span class="hljs-string">"url"</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-comment">&lt;!-- 缩写 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">:href</span>=<span class="hljs-string">"url"</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-comment">&lt;!-- 动态参数的缩写 (2.6.0+) --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">:</span>[<span class="hljs-attr">key</span>]=<span class="hljs-string">"url"</span>&gt;</span> ... <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></code></pre><h2 id="条件与循环"><a href="#条件与循环" class="headerlink" title="条件与循环"></a>条件与循环</h2><ul><li><p>判断</p><p>使用<code>v-if</code>判断，也可以使用<code>v-show</code>，在2.1.0 新增<code>v-else-if</code>搭配<code>v-if</code>和<code>v-else</code>使用</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app-1"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"bool"</span>&gt;</span>我是True<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-else</span>&gt;</span>我是False<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">"bool"</span>&gt;</span>我是True<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> app1=<span class="hljs-keyword">new</span> Vue(&#123;    el: <span class="hljs-string">'#app-1'</span>,    data: &#123;        bool: <span class="hljs-literal">true</span>    &#125;&#125;);</code></pre><p><strong><code>v-if</code> VS <code>v-show</code></strong></p><p><code>v-if</code> 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。</p><p><code>v-if</code> 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</p><p>相比之下，<code>v-show</code> 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。</p><p>一般来说，<code>v-if</code> 有更高的切换开销，而 <code>v-show</code> 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 <code>v-show</code> 较好；如果在运行时条件很少改变，则使用 <code>v-if</code> 较好。</p><p><strong>注意</strong>：<code>v-show</code>不支持<code>v-else</code>和<code>&lt;template&gt;</code></p></li></ul><ul><li><p>循环</p><p>使用<code>v-for</code>实现循环</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app-2"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"list in lists"</span>&gt;</span>            &#123;&#123;list.text&#125;&#125;        <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> app2 = <span class="hljs-keyword">new</span> Vue(&#123;    el: <span class="hljs-string">'#app-2'</span>,    data: &#123;        lists: [            &#123;<span class="hljs-attr">text</span>: <span class="hljs-string">"学习 Vue"</span>&#125;,            &#123;<span class="hljs-attr">text</span>: <span class="hljs-string">"学习 Spring Boot"</span>&#125;,            &#123;<span class="hljs-attr">text</span>: <span class="hljs-string">"学习 Docker"</span>&#125;        ]    &#125;&#125;)</code></pre></li><li><p>监听事件</p><p><code>v-on:</code>接事件类型，如<code>click</code>,可以绑定Vue中methods的方法事件。</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app-3"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">"sayHi"</span>&gt;</span>点我<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> app3 = <span class="hljs-keyword">new</span> Vue(&#123;        el: <span class="hljs-string">'#app-3'</span>,        data: &#123;            message: <span class="hljs-string">"你点我了！"</span>        &#125;,        methods: &#123;            sayHi: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;                alert(<span class="hljs-keyword">this</span>.message)            &#125;        &#125;    &#125;)</code></pre><p>缩写：</p><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 完整语法 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">"doSomething"</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-comment">&lt;!-- 缩写 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"doSomething"</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-comment">&lt;!-- 动态参数的缩写 (2.6.0+) --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> @[<span class="hljs-attr">event</span>]=<span class="hljs-string">"doSomething"</span>&gt;</span> ... <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></code></pre></li></ul><h2 id="双向绑定"><a href="#双向绑定" class="headerlink" title="双向绑定"></a>双向绑定</h2><p>数据双向绑定，即当数据发生变化的时候，视图也就发生变化，当视图发生变化的时候，数据也会跟着同步变化。</p><p>使用<code>v-model</code>在<code>&lt;input&gt;</code>,<code>&lt;textarea&gt;</code>,<code>&lt;select&gt;</code>上创建双向数据绑定，会根据控件类型，自动选择正确的方法来更新元素。</p><p><code>v-model</code>会忽略表单元素中的value、checked、selected的初始值，而将Vue实例中的数据作为数据来源，因此应该通过JavaScript中的data选项声明初始值。</p><h3 id="文本框"><a href="#文本框" class="headerlink" title="文本框"></a>文本框</h3><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app-1"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"message"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>    &#123;&#123;message&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> app1 = <span class="hljs-keyword">new</span> Vue(&#123;        el: <span class="hljs-string">'#app-1'</span>,        data: &#123;            message: <span class="hljs-string">"初始值"</span>        &#125;    &#125;);</code></pre><h3 id="单选框"><a href="#单选框" class="headerlink" title="单选框"></a>单选框</h3><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app-2"</span>&gt;</span>    性别 ：    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"radio"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"sex"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"男"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"checked"</span>&gt;</span>男    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"radio"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"sex"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"女"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"checked"</span>&gt;</span>女    &#123;&#123;checked&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> app2 = <span class="hljs-keyword">new</span> Vue(&#123;    el: <span class="hljs-string">'#app-2'</span>,    data: &#123;        checked: <span class="hljs-string">''</span>    &#125;&#125;);</code></pre><h3 id="下拉框"><a href="#下拉框" class="headerlink" title="下拉框"></a>下拉框</h3><p>在<code>select</code>中，如果<code>v-model</code>表达式的初始值未能匹配任何选项， 元素将被渲染为“未选中”状态。在 iOS 中，这会使用户无法选择第一个选项。因为这样的情况下，iOS 不会触发 change 事件。因此，推荐提供一个值为空的禁用选项。</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app-3"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"city"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"selected"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">disabled</span> <span class="hljs-attr">value</span>=<span class="hljs-string">""</span>&gt;</span>--请选择--<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>北京<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>上海<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>广州<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>深圳<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>    &#123;&#123;selected&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> app3 = <span class="hljs-keyword">new</span> Vue(&#123;    el: <span class="hljs-string">'#app-3'</span>,    data: &#123;        selected: <span class="hljs-string">''</span>    &#125;&#125;);</code></pre><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><ul><li><p><code>.lazy</code></p><p>在默认情况下，<code>v-model</code> 在每次 <code>input</code> 事件触发后将输入框的值与数据进行同步。添加 <code>lazy</code> 修饰符，从而转为在 <code>change</code> 事件之后进行同步：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">v-model.lazy</span>=<span class="hljs-string">"message1"</span>&gt;</span></code></pre></li><li><p><code>.number</code></p><p>如果想自动将用户的输入值转为数值类型，可以给 <code>v-model</code> 添加 <code>number</code> 修饰符：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"number"</span> <span class="hljs-attr">v-model.number</span>=<span class="hljs-string">"message2"</span>&gt;</span></code></pre></li><li><p><code>.trim</code></p><p>如果要自动过滤用户输入的首尾空白字符，可以给 <code>v-model</code> 添加 <code>trim</code> 修饰符：</p></li></ul><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p>组件是可复用的 <code>Vue</code> 实例，是一组可以重复使用的模板，跟 JSTL 的自定义标签、Thymeleaf 的 <code>th:fragment</code>等框架有着异曲同工之妙。通常一个应用会以一棵嵌套的组件树的形式来组织：</p><p><img src="https://gitee.com/jiantian99/Images-Hosting/raw/master/img/20200819173539.png" srcset="/img/loading.gif" alt></p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">cp</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"c in citys"</span> <span class="hljs-attr">v-bind:item</span>=<span class="hljs-string">"c"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">cp</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><pre><code class="hljs javascript"><span class="hljs-comment">// 先注册组件</span>Vue.component(<span class="hljs-string">'cp'</span>,&#123;    props: [<span class="hljs-string">'item'</span>],    template: <span class="hljs-string">'&lt;li&gt;&#123;&#123;item.city&#125;&#125;&lt;/li&gt;&gt;'</span>&#125;);<span class="hljs-comment">// 再实例化Vue</span><span class="hljs-keyword">var</span> app=<span class="hljs-keyword">new</span> Vue(&#123;    el: <span class="hljs-string">'#app'</span>,    data:&#123;        citys:[            &#123;<span class="hljs-attr">city</span>: <span class="hljs-string">'北京'</span>&#125;,            &#123;<span class="hljs-attr">city</span>: <span class="hljs-string">'上海'</span>&#125;,            &#123;<span class="hljs-attr">city</span>: <span class="hljs-string">'广州'</span>&#125;,            &#123;<span class="hljs-attr">city</span>: <span class="hljs-string">'深圳'</span>&#125;,        ]    &#125;&#125;)</code></pre><p><code>Vue.component()</code>：注册组件</p><p><code>cp</code>：自定义组件名</p><p><code>template</code>：自定义组件的模版</p><p><code>props</code>：传递参数，属性里的值默认不能为大写</p><p><code>v-for=&quot;c in citys&quot;</code>：遍历Vue实例中名为<code>citys</code>的数组，并创建同等数量的组件</p><p><code>v-bind:item=&quot;c&quot;</code>将遍历的<code>c</code>绑定到组件中<code>props</code>定义的名为<code>item</code>属性上；<code>=</code>号左边为 props 定义的属性名，右边的为<code>v-for</code>遍历的值。</p><h2 id="Axios异步通信"><a href="#Axios异步通信" class="headerlink" title="Axios异步通信"></a>Axios异步通信</h2><h3 id="什么是Axios"><a href="#什么是Axios" class="headerlink" title="什么是Axios"></a>什么是Axios</h3><p>Axios 是一个开源的可以用在浏览器端和 <code>NodeJS</code> 的异步通信框架，它的主要作用就是实现 AJAX 异步通信，其功能特点如下：</p><ul><li>从浏览器中创建 <code>XMLHttpRequests</code></li><li>从 node.js 创建 http 请求</li><li>支持 Promise API [JS中链式编程]</li><li>拦截请求和响应</li><li>转换请求数据和响应数据</li><li>取消请求</li><li>自动转换 JSON 数据</li><li>客户端支持防御 XSRF（跨站请求伪造）</li></ul><p>Github：<a href="https://github.com/axios/axios" target="_blank" rel="noopener">https://github.com/axios/axios</a></p><p>中文文档：<a href="http://www.axios-js.com/" target="_blank" rel="noopener">http://www.axios-js.com/</a></p><pre><code class="hljs javascript">&lt;script src=<span class="hljs-string">"https://unpkg.com/axios/dist/axios.min.js"</span>&gt;&lt;<span class="hljs-regexp">/script&gt;</span></code></pre><h3 id="为什么要使用Axios"><a href="#为什么要使用Axios" class="headerlink" title="为什么要使用Axios"></a>为什么要使用Axios</h3><p>由于 <code>Vue.js</code> 是一个 视图层框架 并且作者（尤雨溪）严格准守 SoC （关注度分离原则），所以 <code>Vue.js</code> 并不包含 AJAX 的通信功能，为了解决通信问题，作者单独开发了一个名为 <code>vue-resource</code>的插件，不过在进入 2.0 版本以后停止了对该插件的维护并推荐了 <code>Axios</code> 框架。少用jQuery，因为它操作Dom太频繁！</p><h3 id="使用Axios"><a href="#使用Axios" class="headerlink" title="使用Axios"></a>使用Axios</h3><p>模拟一段JSON数据</p><pre><code class="hljs json">&#123;  <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Hello Vue"</span>,  <span class="hljs-attr">"url"</span>: <span class="hljs-string">"https://cn.vuejs.org/"</span>,  <span class="hljs-attr">"isNormal"</span>: <span class="hljs-literal">true</span>,  <span class="hljs-attr">"address"</span>: &#123;    <span class="hljs-attr">"street"</span>: <span class="hljs-string">"长安街"</span>,    <span class="hljs-attr">"city"</span>: <span class="hljs-string">"北京"</span>,    <span class="hljs-attr">"country"</span>: <span class="hljs-string">"中国"</span>  &#125;,  <span class="hljs-attr">"links"</span>: [    &#123;      <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Github"</span>,      <span class="hljs-attr">"url"</span>: <span class="hljs-string">"https://github.com/"</span>    &#125;,    &#123;      <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Bilibili"</span>,      <span class="hljs-attr">"url"</span>: <span class="hljs-string">"https://www.bilibili.com/"</span>    &#125;,    &#123;      <span class="hljs-attr">"name"</span>: <span class="hljs-string">"JQuery"</span>,      <span class="hljs-attr">"url"</span>: <span class="hljs-string">"https://jquery.com/"</span>    &#125;  ]&#125;</code></pre><p>测试Html</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;&#123;info.name&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;&#123;info.address.country&#125;&#125;-&#123;&#123;info.address.city&#125;&#125;-&#123;&#123;info.address.street&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"link in info.links"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">target</span>=<span class="hljs-string">"_blank"</span> <span class="hljs-attr">v-bind:href</span>=<span class="hljs-string">"link.url"</span>&gt;</span>&#123;&#123;link.name&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://unpkg.com/axios/dist/axios.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="actionscript">    <span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;</span><span class="actionscript">        el: <span class="hljs-string">'#app'</span>,</span>        data() &#123;<span class="actionscript">            <span class="hljs-keyword">return</span> &#123;</span>                info: &#123;<span class="actionscript">                    name: <span class="hljs-literal">null</span>,</span><span class="actionscript">                    url: <span class="hljs-literal">null</span>,</span>                    address: &#123;<span class="actionscript">                        street: <span class="hljs-literal">null</span>,</span><span class="actionscript">                        city: <span class="hljs-literal">null</span>,</span><span class="actionscript">                        country: <span class="hljs-literal">null</span></span>                    &#125;,                    links: [                        &#123;<span class="actionscript">                            name: <span class="hljs-literal">null</span>,</span><span class="actionscript">                            url: <span class="hljs-literal">null</span></span>                        &#125;                    ]                &#125;            &#125;        &#125;,        mounted() &#123;<span class="javascript">            axios.get(<span class="hljs-string">'data.json'</span>).then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> (<span class="hljs-keyword">this</span>.info = response.data))</span>        &#125;    &#125;);<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><ul><li>使用<code>v-bind</code>将<code>a:href</code>的属性值与Vue实例中的数据进行绑定</li><li>使用Axios中的get方法请求AJAX并自动将数据封装进Vue实例中的数据对象</li><li>Vue实例中的data数据结构必须与AJAX响应回来的数据格式匹配</li></ul><h2 id="Vue生命周期"><a href="#Vue生命周期" class="headerlink" title="Vue生命周期"></a>Vue生命周期</h2><p>Vue 实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模板、挂载 DOM、渲染→更新→渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。通俗说就是 Vue 实例从创建到销毁的过程，就是生命周期。</p><p>在 Vue 的整个生命周期中，它提供了一系列的事件，可以让我们在事件触发时注册 JS 方法，可以让我们用自己注册的 JS 方法控制整个大局，在这些事件响应方法中的 this 直接指向的是 Vue 的实例。</p><p><img src="https://gitee.com/jiantian99/Images-Hosting/raw/master/img/20200820103019.png" srcset="/img/loading.gif" alt></p><h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><p>计算属性的重点突出在 <code>属性</code> 两个字上（属性是名词），首先它是个 <code>属性</code> 其次这个属性有 <code>计算</code>的能力（计算是动词），这里的 <code>计算</code> 就是个函数；简单点说，它就是一个能够将计算结果缓存起来的属性（将行为转化成了静态的属性），仅此而已；可以想象为缓存！</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>调用当前时间的方法：&#123;&#123;currentTime1()&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>当前时间的计算属性：&#123;&#123;currentTime2&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="actionscript">    <span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;</span><span class="actionscript">        el: <span class="hljs-string">'#app'</span>,</span>        methods: &#123;<span class="actionscript">            currentTime1: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>&#123;</span><span class="javascript">                <span class="hljs-keyword">return</span> <span class="hljs-built_in">Date</span>.now();</span>            &#125;        &#125;,        computed:&#123;<span class="actionscript">            currentTime2: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>&#123;</span><span class="actionscript">                <span class="hljs-keyword">this</span>.message;</span><span class="javascript">                <span class="hljs-keyword">return</span> <span class="hljs-built_in">Date</span>.now();</span>            &#125;        &#125;    &#125;)<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><ul><li>methods和computed中的不能重名，否则methods的优先级高于computed</li><li>methods中的是方法，调用需要带括号；computed中的是属性，调用不需要带括号</li><li>methods中的方法，每次调用，都需再次执行函数；而computed中的属性，只在数据发生变化，才重新求值，这就意味着<code>message</code>没有发生变化，多次调用<code>currentTime2</code>，只会返回之前缓存的计算结果，不必再次执行函数</li></ul><p>总结：在调用方法时，每次都需要进行计算，在计算过程中就会产生开销。如果结果不是经常变化，可以使用计算属性，把这个结果缓存起来，以节约系统开销。</p><h2 id="内容分发"><a href="#内容分发" class="headerlink" title="内容分发"></a>内容分发</h2><p>为了让组件可以组合，需要一种方式来混合父组件的内容与子组件自己的模板。这个过程被称为 <strong>内容分发</strong> (或 “transclusion” )。Vue实现了一个内容分发 API，参照了当前 Web 组件规范草案，使用特殊的 <code>&lt;slot&gt;</code> 元素作为原始内容的插槽。</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">todo</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">todo-title</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">"todo-title"</span> <span class="hljs-attr">title</span>=<span class="hljs-string">"学习清单"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">todo-title</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">todo-items</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">"todo-items"</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"item in todoItems"</span> <span class="hljs-attr">v-bind:item</span>=<span class="hljs-string">"item"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">todo-items</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">todo</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="actionscript">    Vue.component(<span class="hljs-string">'todo'</span>, &#123;</span><span class="actionscript">        template: <span class="hljs-string">'&lt;div&gt;'</span> +</span><span class="handlebars"><span class="xml">        '<span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"todo-title"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span>' +</span></span><span class="actionscript">        <span class="hljs-string">'&lt;ul&gt;'</span> +</span><span class="handlebars"><span class="xml">        '<span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"todo-items"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span>' +</span></span><span class="actionscript">        <span class="hljs-string">'&lt;/ul&gt;'</span> +</span><span class="actionscript">        <span class="hljs-string">'&lt;/div&gt;'</span></span>    &#125;);<span class="actionscript">    <span class="hljs-comment">// todo-title组件</span></span><span class="actionscript">    Vue.component(<span class="hljs-string">'todo-title'</span>, &#123;</span><span class="actionscript">        props: [<span class="hljs-string">'title'</span>],</span><span class="handlebars"><span class="xml">        template: '<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;title&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>'</span></span>    &#125;);<span class="actionscript">    <span class="hljs-comment">// todo-items组件</span></span><span class="actionscript">    Vue.component(<span class="hljs-string">'todo-items'</span>, &#123;</span><span class="actionscript">        props: [<span class="hljs-string">'item'</span>],</span><span class="handlebars"><span class="xml">        template: '<span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;item&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>'</span></span>    &#125;);<span class="actionscript">    <span class="hljs-comment">// 实例化Vue并初始化数据</span></span><span class="actionscript">    <span class="hljs-keyword">var</span> app = <span class="hljs-keyword">new</span> Vue(&#123;</span><span class="actionscript">        el: <span class="hljs-string">'#app'</span>,</span>        data: &#123;<span class="actionscript">            todoItems: [<span class="hljs-string">'Java'</span>, <span class="hljs-string">'Vue'</span>, <span class="hljs-string">'Linux'</span>]</span>        &#125;    &#125;);<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><p><code>todo-title</code>和 <code>todo-items</code> 组件分别被分发到了 <code>todo</code> 组件的 todo-title 和 todo-items 插槽中，三个组件相互独立。</p><p>如果<code>&lt;todo&gt;</code>的<code>template</code>中没有包含一个<code>&lt;slot&gt;</code>元素，则该组件起始标签和结束标签之间的任何内容都会被抛弃。</p><p>父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。</p><h2 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h2><p>父组件使用<code>props</code>传递数据给子组件，而子组件使用<strong>自定义事件</strong>与父组件通信。</p><h3 id="事件名"><a href="#事件名" class="headerlink" title="事件名"></a>事件名</h3><p>自定义事件的命名具备HTML特性，对大小写不敏感，推荐使用kebab-case（短横线）<code>-</code>命名方式。</p><h3 id="数据传递"><a href="#数据传递" class="headerlink" title="数据传递"></a>数据传递</h3><p>子组件通过<code>$emit</code>触发事件，父组件通过<code>$on</code>监听事件</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>总数：&#123;&#123; total &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">my-component</span></span><span class="hljs-tag">                  @<span class="hljs-attr">increase</span>=<span class="hljs-string">"GetTotal"</span></span><span class="hljs-tag">                  @<span class="hljs-attr">reduce</span>=<span class="hljs-string">"GetTotal"</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">my-component</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="actionscript">    Vue.component(<span class="hljs-string">'my-component'</span>, &#123;</span><span class="handlebars"><span class="xml">        template: '<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\</span></span><span class="handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"handleIncrease"</span>&gt;</span>+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\</span></span><span class="handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"handleReduce"</span>&gt;</span>-1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\</span></span><span class="handlebars"><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>',</span></span><span class="actionscript">        data: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>&#123;</span><span class="actionscript">        <span class="hljs-keyword">return</span> &#123;</span>            counter: 0        &#125;    &#125;,        methods: &#123;<span class="actionscript">            handleIncrease: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>&#123;</span><span class="actionscript">                <span class="hljs-keyword">this</span>.counter++;</span><span class="actionscript">                <span class="hljs-keyword">this</span>.$emit(<span class="hljs-string">'increase'</span>, <span class="hljs-keyword">this</span>.counter);</span>            &#125;,<span class="actionscript">                handleReduce: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>&#123;</span><span class="actionscript">                    <span class="hljs-keyword">this</span>.counter--;</span><span class="actionscript">                    <span class="hljs-keyword">this</span>.$emit(<span class="hljs-string">'reduce'</span>, <span class="hljs-keyword">this</span>.counter);</span>                &#125;        &#125;    &#125;);<span class="actionscript">    <span class="hljs-keyword">var</span> app = <span class="hljs-keyword">new</span> Vue(&#123;</span><span class="actionscript">        el: <span class="hljs-string">'#app'</span>,</span>        data: &#123;            total: 0        &#125;,        methods: &#123;<span class="actionscript">            GetTotal: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(total)</span> </span>&#123;</span><span class="actionscript">                <span class="hljs-keyword">this</span>.total = total;</span>            &#125;        &#125;    &#125;)<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><p>在上面的示例中，通过修改子组件中的<code>counter</code>值，改变父组件中的<code>total</code>值。子组件中绑定<code>click</code>事件，通过<code>this.$emit()</code>绑定父组件中的事件名及传递参数，再绑定到Vue中的方法中。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Vue核心：数据驱动 , 组件化</p><p>优点 : 借鉴了 AngulaJS 的模块化开发 和 React 的虚拟Dom , 虚拟Dom就是把Dom操作放到内存中执行</p><p>常用的属性：</p><ul><li>v-if   判断</li><li>v-else-if</li><li>v-else</li><li>v-for  循环</li><li>v-on   绑定事件，简写<code>@</code></li><li>v-model 数据双向绑定</li><li>v-bind 给组件绑定参数，简写<code>:</code></li></ul><p>组件化：</p><ul><li>计算属性：缓存计算数据</li><li>组合组件<code>slot</code>插槽</li><li>组件内部绑定事件<code>this.$emit(&#39;事件名&#39;，参数)</code></li></ul><p>解决通信问题，使用<code>Axios</code>框架做异步通信。</p><hr><p>参考资料：</p><p><a href="https://www.bilibili.com/video/BV18E411a7mC" target="_blank" rel="noopener">狂神说Java</a></p><p><a href="https://cn.vuejs.org/v2/guide/" target="_blank" rel="noopener">Vue</a></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue，前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Boot:YAML配置文件 </title>
    <link href="/2020/08/10/Spring-Boot-YAML/"/>
    <url>/2020/08/10/Spring-Boot-YAML/</url>
    
    <content type="html"><![CDATA[<h2 id="YAML概述"><a href="#YAML概述" class="headerlink" title="YAML概述"></a>YAML概述</h2><p><a href="http://www.yaml.org/" target="_blank" rel="noopener">YAML</a> 是 “YAML Ain’t a Markup Language”（YAML 不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：”Yet Another Markup Language”（仍是一种标记语言）。</p><h2 id="YAML基础语法"><a href="#YAML基础语法" class="headerlink" title="YAML基础语法"></a>YAML基础语法</h2><ul><li>属性和值大小写敏感</li><li>使用缩进来控制层级关系，缩进不允许使用tab，只允许空格</li><li>空格个数不限制，只要左对齐的一列数据属于同一层级即可</li></ul><h3 id="纯量"><a href="#纯量" class="headerlink" title="纯量"></a>纯量</h3><p>纯量：普通的值 （数字，字符串，布尔值）</p><pre><code class="hljs q"><span class="hljs-built_in">key</span>: <span class="hljs-built_in">value</span></code></pre><p>注：</p><ol><li><p>字符串默认不用加上引号</p></li><li><p><code>&#39;&#39;</code>单引号会转义特殊字符，特殊字符会以普通字符形式输出，而<code>&quot;&quot;</code>双引号不会。</p><pre><code class="hljs s">str1: &#39;hello \n world&#39;str2: &quot;hello \n world&quot;</code></pre><p>输出</p><pre><code class="hljs 1c">hello \n world    <span class="hljs-comment">// str1</span>hello             <span class="hljs-comment">// str2</span>world</code></pre></li></ol><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><pre><code class="hljs yaml"><span class="hljs-attr">key:</span>  <span class="hljs-attr">child-key1:</span> <span class="hljs-string">value1</span>  <span class="hljs-attr">child-key2:</span> <span class="hljs-string">value2</span></code></pre><p>注意缩进</p><pre><code class="hljs yaml"><span class="hljs-attr">user:</span>  <span class="hljs-attr">id:</span> <span class="hljs-number">1001</span>  <span class="hljs-attr">name:</span> <span class="hljs-string">Mike</span></code></pre><p>行内写法</p><pre><code class="hljs css"><span class="hljs-selector-tag">user</span>: &#123;<span class="hljs-attribute">id</span>: <span class="hljs-number">1001</span>,name: Mike&#125;</code></pre><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>使用<code>-</code>标识数组中的一个元素</p><pre><code class="hljs markdown">fruit:<span class="hljs-bullet">  - </span>apple<span class="hljs-bullet">  - </span>banana<span class="hljs-bullet">  - </span>cherry</code></pre><p>行内写法</p><pre><code class="hljs apache"><span class="hljs-attribute">fruit</span>:<span class="hljs-meta"> [apple,banana,chrry]</span></code></pre><h2 id="Spring-Boot中使用YAML"><a href="#Spring-Boot中使用YAML" class="headerlink" title="Spring Boot中使用YAML"></a>Spring Boot中使用YAML</h2><h3 id="使用全局配置文件"><a href="#使用全局配置文件" class="headerlink" title="使用全局配置文件"></a>使用全局配置文件</h3><p>使用全局配置文件application.yaml，修改Spring Boot自动配置的默认值</p><p>例：修改Tomcat默认启动端口号</p><pre><code class="hljs yaml"><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">8081</span></code></pre><h3 id="给实体类注入匹配值"><a href="#给实体类注入匹配值" class="headerlink" title="给实体类注入匹配值"></a>给实体类注入匹配值</h3><p>实体类 User类和Fruit类</p><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-meta">@Component</span>        <span class="hljs-comment">//注册bean</span><span class="hljs-meta">@ConfigurationProperties</span>(prefix = <span class="hljs-string">"user1"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;    <span class="hljs-keyword">private</span> Integer id;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> vip;    <span class="hljs-keyword">private</span> Date birthday;    <span class="hljs-keyword">private</span> Map&lt;String,Object&gt; maps;    <span class="hljs-keyword">private</span> List&lt;Object&gt; lists;    <span class="hljs-keyword">private</span> Fruit fruit;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fruit</span> </span>&#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> price;&#125;</code></pre><p><code>@ConfigurationProperties</code>默认从全局配置文件中获取每一个属性的值，并映射到这个组件中；告诉Spring Boot将本类中的所有属性和配置文件中的相关配置进行绑定；</p><p>参数<code>perfix=&quot;user1&quot;</code>，将配置文件中的user1中的所有属性进行一一对应。</p><p>使用yaml配置方式进行注入</p><pre><code class="hljs yaml"><span class="hljs-attr">user1:</span>  <span class="hljs-attr">id:</span> <span class="hljs-number">1001</span>  <span class="hljs-attr">name:</span> <span class="hljs-string">李四$&#123;random.uuid&#125;</span>  <span class="hljs-attr">vip:</span> <span class="hljs-literal">false</span>  <span class="hljs-attr">birthday:</span> <span class="hljs-number">2020</span><span class="hljs-string">/1/1</span>  <span class="hljs-attr">maps:</span> <span class="hljs-string">&#123;key1:</span> <span class="hljs-string">v1,k2:</span> <span class="hljs-string">v2&#125;</span>  <span class="hljs-attr">lists:</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">li1</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">li2</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">li3</span>  <span class="hljs-attr">fruit:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">苹果</span>    <span class="hljs-attr">price:</span> <span class="hljs-number">6.6</span></code></pre><ol><li>yaml配置文件中可以使用占位符，生成随机数；</li><li>如果将配置文件中的key值与实体类中的值设置不一致，则注入失败，输出结果为null。</li></ol><p>测试</p><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloworldApplicationTests</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> User user;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(user);    &#125;&#125;</code></pre><p><img src="https://gitee.com/jiantian99/Images-Hosting/raw/master/img/20200810173631.png" srcset="/img/loading.gif" alt></p><h3 id="与properties对比"><a href="#与properties对比" class="headerlink" title="与properties对比"></a>与properties对比</h3><table><thead><tr><th align="center"></th><th align="center">yaml</th><th align="center">properties</th></tr></thead><tbody><tr><td align="center">注入使用</td><td align="center">@ConfigurationProperties</td><td align="center">@Value</td></tr><tr><td align="center">功能</td><td align="center">批量注入配置文件中的属性</td><td align="center">需一个个绑定</td></tr><tr><td align="center">SpEl</td><td align="center">不支持</td><td align="center">支持</td></tr><tr><td align="center">JSR303数据校验</td><td align="center">支持</td><td align="center">不支持</td></tr><tr><td align="center">封装复杂数据类型</td><td align="center">支持</td><td align="center">不支持</td></tr><tr><td align="center">松散绑定</td><td align="center">支持</td><td align="center">不支持</td></tr></tbody></table><ol><li>@ConfigurationProperties只需要写一次，@Value需要一一绑定；</li><li>JSR303数据校验，在字段中添加一层过滤器校验，保证数据的合法性；</li><li>松散绑定：first-name等于firstName，<code>-</code>后的字母默认大写；</li><li>使用yaml方法，是Spring Boot所推荐的；如果只需要获取配置文件中的某个值，可以使用<code>@Value</code>。</li></ol>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringBoot,YAML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈Spring</title>
    <link href="/2020/08/01/%E6%B5%85%E8%B0%88Spring/"/>
    <url>/2020/08/01/%E6%B5%85%E8%B0%88Spring/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是Spring"><a href="#什么是Spring" class="headerlink" title="什么是Spring"></a>什么是Spring</h2><p>Spring 是一个轻量级Java开发开源框架，是为了解决企业级应用开发的复杂性而创建的，简化开发过程。Spring是⼀个轻量级的控制反转（IoC）和⾯向切⾯（AOP）的容器框架。</p><h2 id="Spring体系结构"><a href="#Spring体系结构" class="headerlink" title="Spring体系结构"></a>Spring体系结构</h2><p><img src="https://gitee.com/jiantian99/Images-Hosting/raw/master/img/20200809173931.png" srcset="/img/loading.gif" alt></p><h2 id="IOC和DI"><a href="#IOC和DI" class="headerlink" title="IOC和DI"></a>IOC和DI</h2><h3 id="IOC：控制反转"><a href="#IOC：控制反转" class="headerlink" title="IOC：控制反转"></a>IOC：控制反转</h3><p>控制反转即控制权的转移，是Spring框架的核心，用来消减程序的耦合问题。</p><p>在传统开发模式下，调用者通过“new 被调用者”的方式创建对象。这种方式增加调用者和被调用者之间的耦合性，不利于后期维护。</p><p>使用Spring后，对象的创建由Spring容器完成，Spring容器负责控制程序间的关系，使得控制权由调用者转移到Spring容器，控制器发生了反转。</p><p>举例加深理解：我想吃面包。当某个Java对象（调用者：我），调用另一个Java对象（被调用者：面包）时，在传统编程模式下：使用new方法（自己制作面包）；使用Spring：对象的实例（面包）由Spring容器（面包店）创建，Spring容器负责控制程序间的关系（面包店负责我与面包之间的关系）。</p><h3 id="DI：依赖注入"><a href="#DI：依赖注入" class="headerlink" title="DI：依赖注入"></a>DI：依赖注入</h3><p>Spring容器中，管理一系列的类，但调用者需要调用时，Spring容器负责将依赖对象赋值给调用者的成员变量，为调用者注入所依赖的实例。</p><p>举例：面包店给我需要的菠萝包。</p><p><img src="https://gitee.com/jiantian99/Images-Hosting/raw/master/img/20200809174012.png" srcset="/img/loading.gif" alt></p><p>综上所述，控制反转是一种通过描述（XML或者注解）并通过第三方产生或获取特定对象的方式。在Spring中，实现控制反转的是IOC容器，实现方法是DI（构造方法注入、setter方法注入、接口注入）。</p><h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><h3 id="什么是AOP"><a href="#什么是AOP" class="headerlink" title="什么是AOP"></a>什么是AOP</h3><ol><li>AOP即面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。</li><li>AOP是OOP（⾯向对象编程）的延续，是软件开发中的⼀个热点，也是Spring框架中的⼀个重要内<br>容，是函数式编程的⼀种衍⽣范型。</li><li>利⽤AOP可以对业务逻辑的各个部分进⾏隔离，从⽽使得业务逻辑各部分之间的耦合度降低，提⾼程<br>序的可重⽤性，同时提⾼了开发的效率。</li><li>AOP采取横向抽取机制，取代了传统纵向继承体系重复性代码。</li><li>作用：在程序运行期间，不修改源码对已有方法进行增强；</li><li>应用：事务管理、性能监视、安全检查、缓存、⽇志等。</li></ol><p>将公共的业务 (日志 , 安全等) 和领域业务结合起来 , 当执行领域业务时 , 将会把公共业务加进来 。实现公共业务的重复利用，领域业务更纯粹 ，其本质还是动态代理。</p><h3 id="AOP在Spring中的作用"><a href="#AOP在Spring中的作用" class="headerlink" title="AOP在Spring中的作用"></a>AOP在Spring中的作用</h3><p>提供声明式事务；允许用户自定义切面</p><p><img src="https://gitee.com/jiantian99/Images-Hosting/raw/master/img/20200809174228.png" srcset="/img/loading.gif" alt></p><p>常用术语：</p><ul><li>切面（ASPECT）：横切关注点被模块化的特殊对象，是切⼊点pointcut和通知advice的结合。即，它是一个类。</li><li>连接点（JointPoint）：与切入点匹配的执行点，指那些可能被拦截到的⽅法。</li><li>切入点（PointCut）：切面通知 执行的 “地点”的定义。例如：addUser()。</li><li>通知（Advice）：切面必须要完成的工作。即，它是类中的一个方法。例如：before，after。</li><li>目标（Target）：目标类，被通知对象。例如：UserService</li><li>代理（Proxy）：向目标对象应用通知之后创建的对象。</li><li>织⼊（Weaving）：是指把增强advice应⽤到⽬标对象target，来创建新的代理对象proxy的过程。</li></ul><h2 id="Spring事务"><a href="#Spring事务" class="headerlink" title="Spring事务"></a>Spring事务</h2><p>事务就是把一系列的动作当成一个独立的工作单元，这些动作要么全部完成，要么全部不起作用。</p><h3 id="事务四大基本特性"><a href="#事务四大基本特性" class="headerlink" title="事务四大基本特性"></a>事务四大基本特性</h3><ol><li><p>原子性（atomicity）</p><ul><li>事务是原子性操作，由一系列动作组成，事务的原子性确保动作要么全部完成，要么完全不起作用。</li></ul></li><li><p>一致性（consistency）</p><ul><li>一旦所有事务动作完成，事务就要被提交。数据和资源处于一种满足业务规则的一致性状态中。</li></ul></li><li><p>隔离性（isolation）</p><ul><li>可能多个事务会同时处理相同的数据，因此每个事务都应该与其他事务隔离开来，防止数据损坏。</li></ul></li><li><p>持久性（durability）</p><ul><li>事务一旦完成，无论系统发生什么错误，结果都不会受到影响。通常情况下，事务的结果被写到持久化存储器中。</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记录使用Hexo的一些坑</title>
    <link href="/2020/07/29/%E6%8C%81%E7%BB%AD%E8%AE%B0%E5%BD%95%E4%BD%BF%E7%94%A8Hexo%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91/"/>
    <url>/2020/07/29/%E6%8C%81%E7%BB%AD%E8%AE%B0%E5%BD%95%E4%BD%BF%E7%94%A8Hexo%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91/</url>
    
    <content type="html"><![CDATA[<p>本文主要记录使用<a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>过程中遇到的一些坑。  </p><h2 id="Hexo使用Markdown图片无法显示问题"><a href="#Hexo使用Markdown图片无法显示问题" class="headerlink" title="Hexo使用Markdown图片无法显示问题"></a>Hexo使用Markdown图片无法显示问题</h2><p>最近在Hexo上写点东西，发现使用Markdown语法，插入本地图片，网页中无法显示。<br>网上查了下资料，发现Hexo默认无法自动处理文章插入本地图片，需要通过扩展插件支持。</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><ol><li>安装上传本地图片的插件<br>在Hexo项目的根目录下输入<br><code>npm install https://github.com/CodeFalling/hexo-asset-image --save</code></li><li>打开hexo目录下的配置文件_config.yml，修改配置<code>post_asset_folder: flase</code>为<br><code>post_asset_folder: true</code></li><li>本地图片相对路径引用<br>把图片放入source/_posts中文章同名的文件夹中，文章中使用相对路径引用图片<pre><code class="hljs markdown">![<span class="hljs-string">图片标题</span>](<span class="hljs-link">img.png</span>)   //假设图片名称为img.png</code></pre></li><li>本地图片绝对路径引用<br>在source文件夹中，建立存放图片的文件夹（images）<pre><code class="hljs markdown">![<span class="hljs-string">图片标题</span>](<span class="hljs-link">/images/img.png</span>)   //假设图片名称为img.png</code></pre></li><li>使用图床插入网络图片（推荐）<br>受限于服务器性能，若文章中图片过多，加载图片可能会慢。使用网络图床，可提升图片的加载速度。<pre><code class="hljs markdown">![<span class="hljs-string">图片标签</span>](<span class="hljs-link">网络图片地址</span>)</code></pre></li></ol>]]></content>
    
    
    <categories>
      
      <category>日常记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Markdown学习笔记</title>
    <link href="/2020/07/26/Markdown-notes/"/>
    <url>/2020/07/26/Markdown-notes/</url>
    
    <content type="html"><![CDATA[<h1 id="Markdown学习笔记"><a href="#Markdown学习笔记" class="headerlink" title="Markdown学习笔记"></a>Markdown学习笔记</h1><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><pre><code class="hljs clean"># 一级标题## 二级标题###### 六级标题</code></pre><h2 id="段落格式"><a href="#段落格式" class="headerlink" title="段落格式"></a>段落格式</h2><pre><code class="hljs plain">段落的换行  是使用两个以上空格加上回车</code></pre><p>段落的换行<br>是使用两个以上空格加上回车</p><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><pre><code class="hljs asciidoc"><span class="hljs-strong">*斜体字*</span>*<span class="hljs-strong">*粗体*</span><span class="hljs-strong">*</span><span class="hljs-strong">*</span>*<span class="hljs-strong">*粗斜体*</span>*<span class="hljs-strong">*</span></code></pre><p><em>斜体字</em><br><strong>粗体</strong><br><strong><em>粗斜体</em></strong></p><h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><p>三个以上<code>*</code>、<code>-</code>、<code>_</code> 来建立分割线</p><pre><code class="hljs markdown"><span class="hljs-emphasis">***</span></code></pre><hr><h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><p>两端加入<code>~~</code>实现删除线  </p><pre><code class="hljs haml">~~这是删除线~~</code></pre><p><del>这是删除线</del></p><h3 id="下划线文本"><a href="#下划线文本" class="headerlink" title="下划线文本"></a>下划线文本</h3><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">u</span>&gt;</span>这是下划线文本<span class="hljs-tag">&lt;/<span class="hljs-name">u</span>&gt;</span></code></pre><p><u>这是下划线文本</u></p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>数字后接小数点.</p><pre><code class="hljs angelscript"><span class="hljs-number">1.</span> 第<span class="hljs-number">1</span>项<span class="hljs-number">2.</span> 第<span class="hljs-number">2</span>项<span class="hljs-number">3.</span> 第<span class="hljs-number">3</span>项</code></pre><ol><li>第1项</li><li>第2项</li><li>第3项<h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3>使用*、-、_作为标记，标记后接空格，再填写内容<pre><code class="hljs angelscript">* 第<span class="hljs-number">1</span>项* 第<span class="hljs-number">2</span>项* 第<span class="hljs-number">3</span>项</code></pre></li></ol><ul><li>第1项</li><li>第2项</li><li>第3项<h3 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h3>在需要嵌套的子列表前加入4个空格</li></ul><pre><code class="hljs markdown"><span class="hljs-bullet">* </span>第一项内容<span class="hljs-bullet">    1. </span>我是嵌套的子列表<span class="hljs-bullet">    2. </span>我是嵌套的子列表<span class="hljs-bullet">    3. </span>我是嵌套的子列表<span class="hljs-bullet">* </span>第二项内容<span class="hljs-bullet">    1. </span>子列表<span class="hljs-bullet">    2. </span>子列表<span class="hljs-bullet">    3. </span>子列表</code></pre><ul><li>第一项内容<ol><li>我是嵌套的子列表</li><li>我是嵌套的子列表</li><li>我是嵌套的子列表</li></ol></li><li>第二项内容<ol><li>子列表</li><li>子列表</li><li>子列表</li></ol></li></ul><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><p>使用```包裹，可以指定一种语言</p><p>```javascript<br>    alert(‘Hello World’);<br>```</p><pre><code class="hljs javascript">alert(<span class="hljs-string">'Hello World'</span>);</code></pre><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><pre><code class="hljs markdown">[<span class="hljs-string">链接名称</span>](<span class="hljs-link">链接地址</span>)或者<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">直接使用链接地址</span>&gt;</span></span>[<span class="hljs-string">bilibili</span>](<span class="hljs-link">https://www.bilibili.com/</span>)  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">https:</span>//<span class="hljs-attr">www.bilibili.com</span>/&gt;</span></span></code></pre><p><a href="https://www.bilibili.com/" target="_blank" rel="noopener">bilibili</a>  </p><p><a href="https://www.bilibili.com/" target="_blank" rel="noopener">https://www.bilibili.com/</a></p><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><pre><code class="hljs markdown">![<span class="hljs-string">alt 图片名称</span>](<span class="hljs-link">图片地址 "可选标题"</span>)</code></pre><p><img src="https://gitee.com/jiantian99/Images-Hosting/raw/master/img/20200809173354.png" srcset="/img/loading.gif" alt></p><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>使用<code>|</code>分割单元格，使用<code>-</code>分割表头与表格主体<br>| 表格对齐方式 |      |<br>| ———— | —- |<br>| 左对齐       | :–  |<br>| 居中对齐     | :–: |<br>| 右对齐       | –:  |</p><pre><code class="hljs gherkin">|<span class="hljs-string"> 表头1  </span>|<span class="hljs-string"> 表头2 </span>|<span class="hljs-string">  表头3 </span>||<span class="hljs-string"> :----- </span>|<span class="hljs-string"> :---: </span>|<span class="hljs-string"> -----: </span>||<span class="hljs-string"> 左对齐 </span>|<span class="hljs-string"> 居中  </span>|<span class="hljs-string"> 右对齐 </span>||<span class="hljs-string"> 内容1  </span>|<span class="hljs-string"> 内容2 </span>|<span class="hljs-string">  内容3 </span>|</code></pre><table><thead><tr><th align="left">表头1</th><th align="center">表头2</th><th align="right">表头3</th></tr></thead><tbody><tr><td align="left">左对齐</td><td align="center">居中</td><td align="right">右对齐</td></tr><tr><td align="left">内容1</td><td align="center">内容2</td><td align="right">内容3</td></tr></tbody></table><h2 id="Markdown高级"><a href="#Markdown高级" class="headerlink" title="Markdown高级"></a>Markdown高级</h2><h3 id="支持HTML"><a href="#支持HTML" class="headerlink" title="支持HTML"></a>支持HTML</h3><p>不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML </p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">i</span>&gt;</span>i标签<span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span></code></pre><p><i>i标签</i></p><h3 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h3><p>使用反斜杠<code>\</code>转义特殊字符</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
