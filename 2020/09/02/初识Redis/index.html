<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="拉特">
  <meta name="keywords" content="">
  <title>初识Redis - Hang in there</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css" />
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_yg9cfy8wd6.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->

  
<link rel="stylesheet" href="//at.alicdn.com/t/font_1969536_ei11cr74rl.css">



  <script  src="/js/utils.js" ></script>
<meta name="generator" content="Hexo 4.2.1"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>ljtian's blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2020-09-02 22:00">
      2020年9月2日 晚上
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      13.8k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      181
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
            <article class="markdown-body">
              <h2 id="Redis入门"><a href="#Redis入门" class="headerlink" title="Redis入门"></a>Redis入门</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><blockquote>
<p>Redis 是什么</p>
</blockquote>
<p>Redis（<strong>Re</strong>mote <strong>Di</strong>ctionary <strong>S</strong>erver )，即远程字典服务，是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、<strong>Key-Value数据库</strong>，并提供多种语言的API。</p>
<p><a href="https://redis.io/" target="_blank" rel="noopener">官网</a>介绍：</p>
<p>Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 <a href="http://www.redis.cn/topics/data-types-intro.html#strings" target="_blank" rel="noopener">字符串（strings）</a>， <a href="http://www.redis.cn/topics/data-types-intro.html#hashes" target="_blank" rel="noopener">散列（hashes）</a>， <a href="http://www.redis.cn/topics/data-types-intro.html#lists" target="_blank" rel="noopener">列表（lists）</a>， <a href="http://www.redis.cn/topics/data-types-intro.html#sets" target="_blank" rel="noopener">集合（sets）</a>， <a href="http://www.redis.cn/topics/data-types-intro.html#sorted-sets" target="_blank" rel="noopener">有序集合（sorted sets）</a> 与范围查询， <a href="http://www.redis.cn/topics/data-types-intro.html#bitmaps" target="_blank" rel="noopener">bitmaps</a>， <a href="http://www.redis.cn/topics/data-types-intro.html#hyperloglogs" target="_blank" rel="noopener">hyperloglogs</a> 和 <a href="http://www.redis.cn/commands/geoadd.html" target="_blank" rel="noopener">地理空间（geospatial）</a> 索引半径查询。 Redis 内置了 <a href="http://www.redis.cn/topics/replication.html" target="_blank" rel="noopener">复制（replication）</a>，<a href="http://www.redis.cn/commands/eval.html" target="_blank" rel="noopener">LUA脚本（Lua scripting）</a>， <a href="http://www.redis.cn/topics/lru-cache.html" target="_blank" rel="noopener">LRU驱动事件（LRU eviction）</a>，<a href="http://www.redis.cn/topics/transactions.html" target="_blank" rel="noopener">事务（transactions）</a> 和不同级别的 <a href="http://www.redis.cn/topics/persistence.html" target="_blank" rel="noopener">磁盘持久化（persistence）</a>， 并通过 <a href="http://www.redis.cn/topics/sentinel.html" target="_blank" rel="noopener">Redis哨兵（Sentinel）</a>和自动 <a href="http://www.redis.cn/topics/cluster-tutorial.html" target="_blank" rel="noopener">分区（Cluster）</a>提供高可用性（high availability）。</p>
<h3 id="Redis基础"><a href="#Redis基础" class="headerlink" title="Redis基础"></a>Redis基础</h3><ul>
<li><p>Redis默认有16个数据库（DB 0~DB 15），默认使用第0个</p>
<p>使用<code>select 8</code>切换到DB 8，<code>dbsize</code>查看当前DB的大小，与key数量有关</p>
<p><code>keys *</code> 查看当前数据库所有key</p>
<p><code>flushdb</code>清空当前数据库所有key-value键值对</p>
<p><code>flushall</code>清空所有数据库使用key-value键值对</p>
</li>
<li><p>Redis默认是单线程，基于内存操作</p>
<p>Redis的性能瓶颈不是CPU，是机器内存和网络带宽</p>
</li>
</ul>
<h2 id="Redis-key"><a href="#Redis-key" class="headerlink" title="Redis-key"></a>Redis-key</h2><pre><code class="hljs bash">127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> name Tom     <span class="hljs-comment"># 设置键值对</span>
OK
127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> year 2020
OK
127.0.0.1:6379&gt; keys *           <span class="hljs-comment"># 查看所有键</span>
1) <span class="hljs-string">"year"</span>
2) <span class="hljs-string">"name"</span>
127.0.0.1:6379&gt; move name 8      <span class="hljs-comment"># 移动键值对到指定的数据库 DB8</span>
(<span class="hljs-built_in">integer</span>) 1
127.0.0.1:6379&gt; exists name      <span class="hljs-comment"># exists 判断是否存在该键   0--不存在 1--存在</span>
(<span class="hljs-built_in">integer</span>) 0
127.0.0.1:6379&gt; select 8         <span class="hljs-comment"># 移动到DB8</span>
OK
127.0.0.1:6379[8]&gt; exists name
(<span class="hljs-built_in">integer</span>) 1
127.0.0.1:6379[8]&gt; del name      <span class="hljs-comment"># 删除键值对   返回删除的个数</span>
(<span class="hljs-built_in">integer</span>) 1
127.0.0.1:6379[8]&gt; keys *
(empty array)
127.0.0.1:6379[8]&gt; select 0      <span class="hljs-comment"># 移动到DB0</span>
OK
127.0.0.1:6379&gt; keys *
1) <span class="hljs-string">"year"</span>
127.0.0.1:6379&gt; ttl year         <span class="hljs-comment"># 查看key的过期剩余时间 当前key没有设置过期时间，返回-1</span>
(<span class="hljs-built_in">integer</span>) -1
127.0.0.1:6379&gt; expire year 10   <span class="hljs-comment"># expire 设置 key 的 过期时间 单位为秒</span>
(<span class="hljs-built_in">integer</span>) 1
127.0.0.1:6379&gt; ttl year         <span class="hljs-comment"># 查看key的过期剩余时间 单位为秒</span>
(<span class="hljs-built_in">integer</span>) 6
127.0.0.1:6379&gt; ttl year
(<span class="hljs-built_in">integer</span>) 1
127.0.0.1:6379&gt; ttl year         <span class="hljs-comment"># 当前key设置了过期时间，且key已过期，返回-2</span>
(<span class="hljs-built_in">integer</span>) -2
127.0.0.1:6379&gt; get year         <span class="hljs-comment"># key过期后，自动删除</span>
(nil)
127.0.0.1:6379&gt; keys *
(empty array)

127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> name Mike
OK
127.0.0.1:6379&gt; keys *
1) <span class="hljs-string">"name"</span>
127.0.0.1:6379&gt; get name
<span class="hljs-string">"Mike"</span>
127.0.0.1:6379&gt; rename name username      <span class="hljs-comment"># 修改key的名称</span>
OK
127.0.0.1:6379&gt; keys *
1) <span class="hljs-string">"username"</span>
127.0.0.1:6379&gt; get username
<span class="hljs-string">"Mike"</span></code></pre>

<p>更多Redis-key命令，参考<a href="http://www.redis.cn/commands.html" target="_blank" rel="noopener">官方文档</a></p>
<h2 id="Redis五大数据类型"><a href="#Redis五大数据类型" class="headerlink" title="Redis五大数据类型"></a>Redis五大数据类型</h2><h3 id="String-字符串"><a href="#String-字符串" class="headerlink" title="String 字符串"></a>String 字符串</h3><pre><code class="hljs bash">127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> info hello
OK
127.0.0.1:6379&gt; get info
<span class="hljs-string">"hello"</span>
127.0.0.1:6379&gt; append info world          <span class="hljs-comment"># 向指定的key后追加value  成功返回追加后的字符串长度</span>
(<span class="hljs-built_in">integer</span>) 10
127.0.0.1:6379&gt; get info                   
<span class="hljs-string">"helloworld"</span>
127.0.0.1:6379&gt; strlen info                <span class="hljs-comment"># 获取key对应的value 字符串长度</span>
(<span class="hljs-built_in">integer</span>) 10
127.0.0.1:6379&gt; getrange info 5 7          <span class="hljs-comment"># 按起止位置（闭区间）获取字符串</span>
<span class="hljs-string">"wor"</span>
127.0.0.1:6379&gt; getrange info 5 -1         <span class="hljs-comment"># 按起到最末位置</span>
<span class="hljs-string">"world"</span>
127.0.0.1:6379&gt; setrange info 5 apple      <span class="hljs-comment"># 替换掉从该位置开始的value</span>
(<span class="hljs-built_in">integer</span>) 10
127.0.0.1:6379&gt; get info
<span class="hljs-string">"helloapple"</span>
127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> views 0
OK
127.0.0.1:6379&gt; incr views                 <span class="hljs-comment"># views++           返回增加后的值</span>
(<span class="hljs-built_in">integer</span>) 1
127.0.0.1:6379&gt; incrby views 10            <span class="hljs-comment"># 按照指定的步长增加  返回增加后的值</span>
(<span class="hljs-built_in">integer</span>) 11
127.0.0.1:6379&gt; decr views                 <span class="hljs-comment"># views--           返回增加后的值</span>
(<span class="hljs-built_in">integer</span>) 10
127.0.0.1:6379&gt; decrby views 8             <span class="hljs-comment"># 按照指定的步长减少  返回增加后的值</span>
(<span class="hljs-built_in">integer</span>) 2
127.0.0.1:6379&gt; incrbyfloat views 0.8      <span class="hljs-comment"># 增加浮点数       </span>
<span class="hljs-string">"2.8"</span>
127.0.0.1:6379&gt; setnx views 2              <span class="hljs-comment"># 仅当key不存在时，进行set  失败返回0</span>
(<span class="hljs-built_in">integer</span>) 0
127.0.0.1:6379&gt; getset info hi             <span class="hljs-comment"># 先get 再set   如果不存在返回nil</span>
<span class="hljs-string">"helloapple"</span>
127.0.0.1:6379&gt; get info
<span class="hljs-string">"hi"</span>
127.0.0.1:6379&gt; mset k1 v1 k2 v2 k3 v3     <span class="hljs-comment"># 批量set</span>
OK
127.0.0.1:6379&gt; keys *
1) <span class="hljs-string">"info"</span>
2) <span class="hljs-string">"k2"</span>
3) <span class="hljs-string">"k1"</span>
4) <span class="hljs-string">"k3"</span>
127.0.0.1:6379&gt; mget k1 k2 k3              <span class="hljs-comment"># 批量get</span>
1) <span class="hljs-string">"v1"</span>
2) <span class="hljs-string">"v2"</span>
3) <span class="hljs-string">"v3"</span>
127.0.0.1:6379&gt; msetnx k1 v1 k4 v4         <span class="hljs-comment"># 批量setnx 原子性---全为真才执行</span>
(<span class="hljs-built_in">integer</span>) 0</code></pre>

<p>String 的value可以是字符串或者数字</p>
<p>场景：</p>
<ul>
<li>计数器</li>
<li>对象存储缓存</li>
<li>统计多单位的数量 ：  set uid:1001:views 100</li>
</ul>
<h3 id="List-列表"><a href="#List-列表" class="headerlink" title="List 列表"></a>List 列表</h3><p><img src="https://gitee.com/jiantian99/Images-Hosting/raw/master/img/20200907230115.png" srcset="/img/loading.gif" alt></p>
<p>Redis中List可以双向操作，大部分命令可以分为Lxxx和Rxxx两种，部分命令L代表List，如LLEN、LRANGE</p>
<pre><code class="hljs bash"><span class="hljs-comment"># LPUSH RPUSH LRANGE</span>
127.0.0.1:6379&gt; lpush list k1          <span class="hljs-comment"># 从左边向列表push一个或多个值</span>
(<span class="hljs-built_in">integer</span>) 1
127.0.0.1:6379&gt; lpush list k2 k3
(<span class="hljs-built_in">integer</span>) 3
127.0.0.1:6379&gt; lrange list 0 1        <span class="hljs-comment"># 获取list起止位置的值，从左到右</span>
1) <span class="hljs-string">"k3"</span>
2) <span class="hljs-string">"k2"</span>
127.0.0.1:6379&gt; lrange list 0 -1       <span class="hljs-comment"># 获取list所有元素</span>
1) <span class="hljs-string">"k3"</span>
2) <span class="hljs-string">"k2"</span>
3) <span class="hljs-string">"k1"</span>
127.0.0.1:6379&gt; get list               <span class="hljs-comment"># 无法使用get 获取list的值</span>
(error) WRONGTYPE Operation against a key holding the wrong kind of value
127.0.0.1:6379&gt; rpush list k4          <span class="hljs-comment"># 从右边push一个或多个值</span>
(<span class="hljs-built_in">integer</span>) 4
127.0.0.1:6379&gt; rpush list k5 k6
(<span class="hljs-built_in">integer</span>) 6
127.0.0.1:6379&gt; lrange list 0 -1
1) <span class="hljs-string">"k3"</span>
2) <span class="hljs-string">"k2"</span>
3) <span class="hljs-string">"k1"</span>
4) <span class="hljs-string">"k4"</span>
5) <span class="hljs-string">"k5"</span>
6) <span class="hljs-string">"k6"</span>
<span class="hljs-comment">################################################################################</span>
<span class="hljs-comment"># LPUSHX RPUSHX</span>
127.0.0.1:6379&gt; lpushx newlist k1      <span class="hljs-comment"># 向已存在的list push值 失败返回0</span>
(<span class="hljs-built_in">integer</span>) 0
127.0.0.1:6379&gt; lpushx list k7         <span class="hljs-comment"># 向已存在的list从左push值 成功返回list值的数量</span>
(<span class="hljs-built_in">integer</span>) 7
127.0.0.1:6379&gt; rpushx list k9         <span class="hljs-comment"># 向已存在的list从右push值 成功返回list值的数量</span>
(<span class="hljs-built_in">integer</span>) 8
127.0.0.1:6379&gt; lrange list 0 -1
1) <span class="hljs-string">"k7"</span>
2) <span class="hljs-string">"k3"</span>
3) <span class="hljs-string">"k2"</span>
4) <span class="hljs-string">"k1"</span>
5) <span class="hljs-string">"k4"</span>
6) <span class="hljs-string">"k5"</span>
7) <span class="hljs-string">"k6"</span>
8) <span class="hljs-string">"k9"</span>
<span class="hljs-comment">################################################################################</span>
<span class="hljs-comment"># LINSERT LLEN LINDEX LSET</span>
127.0.0.1:6379&gt; linsert list before k3 k1        <span class="hljs-comment"># 在list中指定元素前或后插入value</span>
(<span class="hljs-built_in">integer</span>) 9
127.0.0.1:6379&gt; lrange list 0 -1
1) <span class="hljs-string">"k7"</span>
2) <span class="hljs-string">"k1"</span>
3) <span class="hljs-string">"k3"</span>
4) <span class="hljs-string">"k2"</span>
5) <span class="hljs-string">"k1"</span>
6) <span class="hljs-string">"k4"</span>
7) <span class="hljs-string">"k5"</span>
8) <span class="hljs-string">"k6"</span>
9) <span class="hljs-string">"k9"</span>
127.0.0.1:6379&gt; llen list                        <span class="hljs-comment"># 获取list长度</span>
(<span class="hljs-built_in">integer</span>) 9
127.0.0.1:6379&gt; lindex list 5                    <span class="hljs-comment"># 根据下标获取值</span>
<span class="hljs-string">"k4"</span>
127.0.0.1:6379&gt; lset list 5 k7                   <span class="hljs-comment"># 将指定下标的元素 设成指定值</span>
OK
127.0.0.1:6379&gt; lrange list 0 -1
1) <span class="hljs-string">"k7"</span>
2) <span class="hljs-string">"k1"</span>
3) <span class="hljs-string">"k3"</span>
4) <span class="hljs-string">"k2"</span>
5) <span class="hljs-string">"k1"</span>
6) <span class="hljs-string">"k7"</span>
7) <span class="hljs-string">"k5"</span>
8) <span class="hljs-string">"k6"</span>
9) <span class="hljs-string">"k9"</span>
<span class="hljs-comment">################################################################################</span>
<span class="hljs-comment"># LPOP RPOP</span>
127.0.0.1:6379&gt; lpop list           <span class="hljs-comment"># 从最左移除值，并返回</span>
<span class="hljs-string">"k7"</span>
127.0.0.1:6379&gt; rpop list           <span class="hljs-comment"># 从最右移除值，并返回</span>
<span class="hljs-string">"k9"</span>
127.0.0.1:6379&gt; lrange list 0 -1
1) <span class="hljs-string">"k1"</span>
2) <span class="hljs-string">"k3"</span>
3) <span class="hljs-string">"k2"</span>
4) <span class="hljs-string">"k1"</span>
5) <span class="hljs-string">"k7"</span>
6) <span class="hljs-string">"k5"</span>
7) <span class="hljs-string">"k6"</span>
<span class="hljs-comment">################################################################################</span>
<span class="hljs-comment"># RPOPLPUSH</span>
127.0.0.1:6379&gt; rpoplpush list newlist    <span class="hljs-comment"># 将list的右边最后一个值弹出，并push进另一个列表头部</span>
<span class="hljs-string">"k6"</span>
127.0.0.1:6379&gt; lrange list 0 -1
1) <span class="hljs-string">"k1"</span>
2) <span class="hljs-string">"k3"</span>
3) <span class="hljs-string">"k2"</span>
4) <span class="hljs-string">"k1"</span>
5) <span class="hljs-string">"k7"</span>
6) <span class="hljs-string">"k5"</span>
127.0.0.1:6379&gt; lrange newlist 0 -1
1) <span class="hljs-string">"k6"</span>
<span class="hljs-comment"># LTRIM</span>
127.0.0.1:6379&gt; ltrim list 0 2             <span class="hljs-comment"># 截取指定区间的列表 </span>
OK
127.0.0.1:6379&gt; lrange list 0 -1
1) <span class="hljs-string">"k1"</span>
2) <span class="hljs-string">"k3"</span>
3) <span class="hljs-string">"k2"</span>
<span class="hljs-comment">################################################################################</span>
<span class="hljs-comment"># LREM</span>
127.0.0.1:6379&gt; lrange list 0 -1
1) <span class="hljs-string">"k2"</span>
2) <span class="hljs-string">"k5"</span>
3) <span class="hljs-string">"k5"</span>
4) <span class="hljs-string">"k1"</span>
5) <span class="hljs-string">"k3"</span>
6) <span class="hljs-string">"k2"</span>
7) <span class="hljs-string">"k5"</span>
127.0.0.1:6379&gt; lrem list 2 k5          <span class="hljs-comment"># 从头部开始搜索，最多删除2个k5</span>
(<span class="hljs-built_in">integer</span>) 2
127.0.0.1:6379&gt; lrange list 0 -1
1) <span class="hljs-string">"k2"</span>
2) <span class="hljs-string">"k1"</span>
3) <span class="hljs-string">"k3"</span>
4) <span class="hljs-string">"k2"</span>
5) <span class="hljs-string">"k5"</span>
127.0.0.1:6379&gt; lrem list -1 k2          <span class="hljs-comment"># 从尾部开始搜索，最多删除1个k2</span>
(<span class="hljs-built_in">integer</span>) 1
127.0.0.1:6379&gt; lrange list 0 -1
1) <span class="hljs-string">"k2"</span>
2) <span class="hljs-string">"k1"</span>
3) <span class="hljs-string">"k3"</span>
4) <span class="hljs-string">"k5"</span>
<span class="hljs-comment">################################################################################</span>
<span class="hljs-comment"># BLPOP  BRPOP</span>
127.0.0.1:6379&gt; lrange list 0 -1
1) <span class="hljs-string">"k2"</span>
2) <span class="hljs-string">"k1"</span>
3) <span class="hljs-string">"k3"</span>
4) <span class="hljs-string">"k5"</span>
127.0.0.1:6379&gt; lrange newlist 0 -1
1) <span class="hljs-string">"k6"</span>
127.0.0.1:6379&gt; blpop newlist list 10      <span class="hljs-comment"># 从左边移除并获取第一个元素，如果列表中没有从候选列表中获取</span>
1) <span class="hljs-string">"newlist"</span>                               <span class="hljs-comment"># 返回弹出元素所属列表 和 元素</span>
2) <span class="hljs-string">"k6"</span>
127.0.0.1:6379&gt; blpop newlist list 10      <span class="hljs-comment"># newlist为空，则从候选列表 list 中获取</span>
1) <span class="hljs-string">"list"</span>
2) <span class="hljs-string">"k2"</span>
127.0.0.1:6379&gt; blpop newlist 10           <span class="hljs-comment"># 列表中没有元素会阻塞列表，直到超时或者发现有可弹出对象</span>
(nil)
(10.01s)
127.0.0.1:6379&gt; blpop newlist 30
1) <span class="hljs-string">"newlist"</span>
2) <span class="hljs-string">"k9"</span>
(4.79s)
127.0.0.1:6379&gt; brpop newlist 30           <span class="hljs-comment"># 在等待的时候，向newlist push进k9，阻塞得到解决</span>
1) <span class="hljs-string">"newlist"</span>                               
2) <span class="hljs-string">"k9"</span>
(2.52s)                                    <span class="hljs-comment"># 返回等待时间</span></code></pre>

<blockquote>
<p>总结</p>
</blockquote>
<ul>
<li><p>list实际上是一个双向链表，left、right，before 节点 after 都可以插入值</p>
</li>
<li><p>如果key不存在，创建新链表</p>
</li>
<li><p>如果key存在，在列表中新增内容</p>
</li>
<li><p>如果移除了所有值，链表为空，即代表不存在</p>
</li>
<li><p>在列表两边插入或改动值，效率最高，列表中间效率较低</p>
</li>
<li><p>应用：</p>
<p>消息排队，消息队列（LPUSH，RPOP），栈（LPUSH，LPOP）</p>
</li>
</ul>
<h3 id="Set-集合"><a href="#Set-集合" class="headerlink" title="Set 集合"></a>Set 集合</h3><p>Redis中的set是String类型的<strong>无序集合</strong>，集合成员<strong>唯一</strong>，集合中不能出现重复数据</p>
<p>Set集合是通过<strong>哈希表</strong>实现，增删查的复杂度都是O(1)</p>
<pre><code class="hljs bash"><span class="hljs-comment"># SADD SCARD SMEMBERS SISMEMBER</span>
127.0.0.1:6379&gt; SADD myset s1               <span class="hljs-comment"># 向集合myset中添加一个成员 s1</span>
(<span class="hljs-built_in">integer</span>) 1
127.0.0.1:6379&gt; SADD myset s2 s3            <span class="hljs-comment"># 向集合myset中添加多个成员</span>
(<span class="hljs-built_in">integer</span>) 2
127.0.0.1:6379&gt; scard myset                 <span class="hljs-comment"># 获取集合中成员的数量</span>
(<span class="hljs-built_in">integer</span>) 3
127.0.0.1:6379&gt; smembers myset              <span class="hljs-comment"># 获取集合中所有成员</span>
1) <span class="hljs-string">"s1"</span>
2) <span class="hljs-string">"s3"</span>
3) <span class="hljs-string">"s2"</span>
127.0.0.1:6379&gt; SISMEMBER myset s2          <span class="hljs-comment"># 查询 s2 是否是myset的成员</span>
(<span class="hljs-built_in">integer</span>) 1                                 <span class="hljs-comment"># 是 返回 1</span>
127.0.0.1:6379&gt; SISMEMBER myset s6
(<span class="hljs-built_in">integer</span>) 0                                 <span class="hljs-comment"># 不是 返回 0</span>
<span class="hljs-comment">################################################################################</span>
<span class="hljs-comment"># SRANDMEMBER SPOP</span>
127.0.0.1:6379&gt; SRANDMEMBER myset           <span class="hljs-comment"># 随机返回1个成员</span>
<span class="hljs-string">"s2"</span>
127.0.0.1:6379&gt; SRANDMEMBER myset 2         <span class="hljs-comment"># 随机返回2个成员</span>
1) <span class="hljs-string">"s1"</span>
2) <span class="hljs-string">"s2"</span>
127.0.0.1:6379&gt; SPOP myset 2                <span class="hljs-comment"># 随机移除并返回2个成员</span>
1) <span class="hljs-string">"s3"</span>
2) <span class="hljs-string">"s2"</span>
127.0.0.1:6379&gt; SMEMBERS myset
1) <span class="hljs-string">"s1"</span>
<span class="hljs-comment">################################################################################</span>
<span class="hljs-comment"># SMOVE SREM</span>
127.0.0.1:6379&gt; SMEMBERS myset
1) <span class="hljs-string">"s4"</span>
2) <span class="hljs-string">"s1"</span>
3) <span class="hljs-string">"s3"</span>
4) <span class="hljs-string">"s2"</span>
5) <span class="hljs-string">"s5"</span>
127.0.0.1:6379&gt; SMEMBERS newset
(empty array)
127.0.0.1:6379&gt; SMOVE myset newset s1      <span class="hljs-comment"># 将myset中的s1成员移动到newset中</span>
(<span class="hljs-built_in">integer</span>) 1
127.0.0.1:6379&gt; SMEMBERS myset
1) <span class="hljs-string">"s3"</span>
2) <span class="hljs-string">"s2"</span>
3) <span class="hljs-string">"s4"</span>
4) <span class="hljs-string">"s5"</span>
127.0.0.1:6379&gt; SMEMBERS newset
1) <span class="hljs-string">"s1"</span>
127.0.0.1:6379&gt; SREM newset s1             <span class="hljs-comment"># 删除newset集合中指定成员 s1</span>
(<span class="hljs-built_in">integer</span>) 1
127.0.0.1:6379&gt; SMEMBERS newset
(empty array)
<span class="hljs-comment">################################################################################</span>
<span class="hljs-comment"># SDIFF SINTER SUNION</span>
<span class="hljs-comment"># set1 &#123;s1,s2,s3&#125; set2 &#123;s3,s4&#125; set3 &#123;s3,s5&#125; </span>
127.0.0.1:6379&gt; SDIFF set1 set2 set3       <span class="hljs-comment"># 差集 等价于 set1-set2-set3</span>
1) <span class="hljs-string">"s1"</span>
2) <span class="hljs-string">"s2"</span>
127.0.0.1:6379&gt; SDIFF set2 set3            <span class="hljs-comment"># 差集 等价于 set2-set3</span>
1) <span class="hljs-string">"s4"</span>
127.0.0.1:6379&gt; SINTER set1 set2 set3      <span class="hljs-comment"># 交集 </span>
1) <span class="hljs-string">"s3"</span>
127.0.0.1:6379&gt; SUNION set1 set2           <span class="hljs-comment"># 并集 相当于set1+set2</span>
1) <span class="hljs-string">"s4"</span>
2) <span class="hljs-string">"s1"</span>
3) <span class="hljs-string">"s2"</span>
4) <span class="hljs-string">"s3"</span>
127.0.0.1:6379&gt; SUNION set1 set2 set3      <span class="hljs-comment"># 并集 相当于set1+set2+set3</span>
1) <span class="hljs-string">"s1"</span>
2) <span class="hljs-string">"s3"</span>
3) <span class="hljs-string">"s2"</span>
4) <span class="hljs-string">"s4"</span>
5) <span class="hljs-string">"s5"</span></code></pre>

<h3 id="Hash-哈希"><a href="#Hash-哈希" class="headerlink" title="Hash 哈希"></a>Hash 哈希</h3><p>Redis 中 Hash是一个String类型的field和value映射表，Hash适合存储对象，经常变更的信息，如用户信息；String更适合字符串存储。</p>
<pre><code class="hljs bash"><span class="hljs-comment"># HSET HMSET HSETNX</span>
127.0.0.1:6379&gt; HSET user name Mike           <span class="hljs-comment"># 把user哈希表作为一个对象 设置name为Mike</span>
(<span class="hljs-built_in">integer</span>) 1
127.0.0.1:6379&gt; HSET user name Tome           <span class="hljs-comment"># 重复设置同一个field会覆盖，且返回0 </span>
(<span class="hljs-built_in">integer</span>) 0
127.0.0.1:6379&gt; HMSET user age 18 sex 1       <span class="hljs-comment"># 同时将多个field-value 设置到Hash中</span>
OK
127.0.0.1:6379&gt; HSETNX user name Joe          <span class="hljs-comment"># 只有field不存在时，才可设置</span>
(<span class="hljs-built_in">integer</span>) 0                                   <span class="hljs-comment"># 失败返回 0</span>
127.0.0.1:6379&gt; HSETNX user id 1001
(<span class="hljs-built_in">integer</span>) 1                                   <span class="hljs-comment"># 成功返回 1</span>
<span class="hljs-comment">######################################################################################</span>
<span class="hljs-comment"># HEXISTS</span>
127.0.0.1:6379&gt; HEXISTS user name             <span class="hljs-comment"># 判断是否存在field 存在返回 1</span>
(<span class="hljs-built_in">integer</span>) 1
127.0.0.1:6379&gt; HEXISTS user email            <span class="hljs-comment"># 不存在返回 0</span>
(<span class="hljs-built_in">integer</span>) 0
<span class="hljs-comment">######################################################################################</span>
<span class="hljs-comment"># HGET HMGET HGETALL</span>
127.0.0.1:6379&gt; HGET user name                <span class="hljs-comment"># 获取user中name字段的value</span>
<span class="hljs-string">"Tome"</span>
127.0.0.1:6379&gt; HMGET user name age id        <span class="hljs-comment"># 获取多个field-value</span>
1) <span class="hljs-string">"Tome"</span>
2) <span class="hljs-string">"18"</span>
3) <span class="hljs-string">"1001"</span>
127.0.0.1:6379&gt; HGETALL user                  <span class="hljs-comment"># 获取所有field-value</span>
1) <span class="hljs-string">"name"</span>                                     <span class="hljs-comment"># field</span>
2) <span class="hljs-string">"Tome"</span>                                     <span class="hljs-comment"># value</span>
3) <span class="hljs-string">"age"</span>
4) <span class="hljs-string">"18"</span>
5) <span class="hljs-string">"sex"</span>
6) <span class="hljs-string">"1"</span>
7) <span class="hljs-string">"id"</span>
8) <span class="hljs-string">"1001"</span>
127.0.0.1:6379&gt; 
<span class="hljs-comment">######################################################################################</span>
<span class="hljs-comment"># HKEYS HLEN HVALS</span>
127.0.0.1:6379&gt; HKEYS user                    <span class="hljs-comment"># 获取哈希表中所有field</span>
1) <span class="hljs-string">"name"</span> 
2) <span class="hljs-string">"age"</span>
3) <span class="hljs-string">"sex"</span>
4) <span class="hljs-string">"id"</span>
127.0.0.1:6379&gt; HLEN user                     <span class="hljs-comment"># 获取哈希表中field的数量</span>
(<span class="hljs-built_in">integer</span>) 4
127.0.0.1:6379&gt; HVALS user                    <span class="hljs-comment"># 获取哈希表中所有value</span>
1) <span class="hljs-string">"Tome"</span>
2) <span class="hljs-string">"18"</span>
3) <span class="hljs-string">"1"</span>
4) <span class="hljs-string">"1001"</span>
<span class="hljs-comment">######################################################################################</span>
<span class="hljs-comment"># HINCRBY</span>
127.0.0.1:6379&gt; HINCRBY user age 1            <span class="hljs-comment"># 给哈希表中指定field的整数量+1 返回增量后的结果</span>
(<span class="hljs-built_in">integer</span>) 19
127.0.0.1:6379&gt; HINCRBY user name 1           <span class="hljs-comment"># 只适用于整数型字段</span>
(error) ERR <span class="hljs-built_in">hash</span> value is not an <span class="hljs-built_in">integer</span>
<span class="hljs-comment">######################################################################################</span>
<span class="hljs-comment"># HDEL</span>
127.0.0.1:6379&gt; HDEL user sex id              <span class="hljs-comment"># 删除一个或多个字段</span>
(<span class="hljs-built_in">integer</span>) 2
127.0.0.1:6379&gt; HKEYS user
1) <span class="hljs-string">"name"</span>
2) <span class="hljs-string">"age"</span></code></pre>

<h3 id="Zset-有序集合"><a href="#Zset-有序集合" class="headerlink" title="Zset 有序集合"></a>Zset 有序集合</h3><p>以Set相比，Zset每个元素都会关联一个<code>double</code>类型的<code>score</code>，redis按照<code>score</code>对成员从小到大进行排序<code>score</code>相同，按字典顺序排序。</p>
<p>Zset中，成员唯一，score不唯一</p>
<p>应用：</p>
<ul>
<li>排序：成绩表、工资表</li>
<li>排行榜</li>
<li>消息：重要消息，带权重判断</li>
</ul>
<pre><code class="hljs bash"><span class="hljs-comment"># ZADD ZCARD ZCOUNT</span>
127.0.0.1:6379&gt; ZADD price 1 apple       <span class="hljs-comment"># 向Zset中添加一个成员 apple 且 score=1</span>
(<span class="hljs-built_in">integer</span>) 1
127.0.0.1:6379&gt; ZADD price 3 watermelon 5 lemon 8 peach 10 grape 12 cherry
(<span class="hljs-built_in">integer</span>) 5                              <span class="hljs-comment"># 向Zset中添加多个成员及其score，返回添加个数</span>
127.0.0.1:6379&gt; ZCARD price              <span class="hljs-comment"># 获取Zset中成员数</span>
(<span class="hljs-built_in">integer</span>) 6
127.0.0.1:6379&gt; ZCOUNT price 0 5         <span class="hljs-comment"># 获取score在 [0,5]区间的成员数量</span>
(<span class="hljs-built_in">integer</span>) 3
<span class="hljs-comment">######################################################################################</span>
<span class="hljs-comment"># ZINCRBY ZSCORE</span>
127.0.0.1:6379&gt; ZINCRBY price 5 cherry   <span class="hljs-comment"># 将成员 cherry score +5</span>
<span class="hljs-string">"17"</span>                                     <span class="hljs-comment"># 返回增加后的score</span>
127.0.0.1:6379&gt; ZSCORE price cherry      <span class="hljs-comment"># 获取成员 cherry 的score</span>
<span class="hljs-string">"17"</span>
127.0.0.1:6379&gt; ZSCORE price lemon
<span class="hljs-string">"5"</span>
<span class="hljs-comment">######################################################################################</span>
<span class="hljs-comment"># ZRANK ZRANGE</span>
127.0.0.1:6379&gt; ZRANGE price 0 3         <span class="hljs-comment"># 获取索引在 0 - 1 之间的成员</span>
1) <span class="hljs-string">"apple"</span>
2) <span class="hljs-string">"watermelon"</span>
3) <span class="hljs-string">"lemon"</span>
4) <span class="hljs-string">"peach"</span>
127.0.0.1:6379&gt; ZRANGE price 0 -1        <span class="hljs-comment"># 获取所有成员</span>
1) <span class="hljs-string">"apple"</span>
2) <span class="hljs-string">"watermelon"</span>
3) <span class="hljs-string">"lemon"</span>
4) <span class="hljs-string">"peach"</span>
5) <span class="hljs-string">"grape"</span>
6) <span class="hljs-string">"cherry"</span>
127.0.0.1:6379&gt; ZRANK price lemon        <span class="hljs-comment"># 获取lemon的索引</span>
(<span class="hljs-built_in">integer</span>) 2
<span class="hljs-comment">######################################################################################</span>
<span class="hljs-comment"># ZRANGEBYLEX                            通过字典区间返回有序集合的成员</span>
127.0.0.1:6379&gt; zrangebylex price - +    <span class="hljs-comment"># 返回所有成员</span>
1) <span class="hljs-string">"apple"</span>
2) <span class="hljs-string">"watermelon"</span>
3) <span class="hljs-string">"lemon"</span>
4) <span class="hljs-string">"peach"</span>
5) <span class="hljs-string">"grape"</span>
6) <span class="hljs-string">"cherry"</span>
<span class="hljs-comment">######################################################################################</span>
<span class="hljs-comment"># ZRANGEBYSCORE</span>
127.0.0.1:6379&gt; ZRANGEBYSCORE price 1 10 <span class="hljs-comment"># 返回score 在[1,10]之间的成员</span>
1) <span class="hljs-string">"apple"</span>
2) <span class="hljs-string">"watermelon"</span>
3) <span class="hljs-string">"lemon"</span>
4) <span class="hljs-string">"peach"</span>
5) <span class="hljs-string">"grape"</span>
<span class="hljs-comment">######################################################################################</span>
<span class="hljs-comment"># ZLEXCOUNT      </span>
127.0.0.1:6379&gt; ZLEXCOUNT price - +      <span class="hljs-comment"># 返回指定字典区间的成员数量</span>
(<span class="hljs-built_in">integer</span>) 6
<span class="hljs-comment">######################################################################################</span>
<span class="hljs-comment"># ZREM ZREMRANGEBYLEX  ZREMRANGBYRANK  ZREMRANGEBYSCORE</span>
127.0.0.1:6379&gt; ZREM price cherry             <span class="hljs-comment"># 删除指定成员</span>
(<span class="hljs-built_in">integer</span>) 1
127.0.0.1:6379&gt; ZREM myset [a [b
(<span class="hljs-built_in">integer</span>) 0
127.0.0.1:6379&gt; ZREMRANGEBYLEX myset [a [b    <span class="hljs-comment"># 删除指定字典区间成员</span>
(<span class="hljs-built_in">integer</span>) 2
127.0.0.1:6379&gt; ZREMRANGEBYRANK price 0 1     <span class="hljs-comment"># 删除排名0-1的成员</span>
(<span class="hljs-built_in">integer</span>) 2
127.0.0.1:6379&gt; ZREMRANGEBYSCORE price 5 8    <span class="hljs-comment"># 删除score在[5,8]之间的成员</span>
(<span class="hljs-built_in">integer</span>) 2
<span class="hljs-comment">######################################################################################</span>
<span class="hljs-comment"># ZREVRANGE     ZREVRANGEBYSCORE    ZREVRANGEBYLEX    ZREVRANK</span>
<span class="hljs-comment"># myset&#123;(m1,0),(m2,0),(m3,0),(m4,1),(m5,2),(m6,3)&#125;</span>
127.0.0.1:6379&gt; ZREVRANGE myset 0 2           <span class="hljs-comment"># 按score递减排序，返回指定索引结果</span>
1) <span class="hljs-string">"m6"</span>
2) <span class="hljs-string">"m5"</span>
3) <span class="hljs-string">"m4"</span>
127.0.0.1:6379&gt; ZREVRANGEBYSCORE myset 3 1    <span class="hljs-comment"># 按score递减排序，返回score在[1,3]结果</span>
1) <span class="hljs-string">"m6"</span>
2) <span class="hljs-string">"m5"</span>
3) <span class="hljs-string">"m4"</span>
127.0.0.1:6379&gt; ZREVRANGEBYLEX myset [m3 (m1  <span class="hljs-comment"># 按字典递减排序，返回集合中(m1,m3]结果</span>
1) <span class="hljs-string">"m3"</span>
2) <span class="hljs-string">"m2"</span>
127.0.0.1:6379&gt; ZREVRANK myset m3             <span class="hljs-comment"># 按score递减排序，返回m3的索引</span>
(<span class="hljs-built_in">integer</span>) 3
<span class="hljs-comment">######################################################################################</span>
<span class="hljs-comment"># ZINTERSTOR   ZUNIONSTORE</span>
<span class="hljs-comment"># math&#123;(Mike,90),(Tom,88),(JOe,80)&#125;</span>
<span class="hljs-comment"># math&#123;(Mike,88),(Tom,76),(JOe,90)&#125;</span>
127.0.0.1:6379&gt; ZINTERSTORE sum 2 math en     <span class="hljs-comment"># 将math 和 en进行合并，存放到sum中</span>
(<span class="hljs-built_in">integer</span>) 3
127.0.0.1:6379&gt; ZRANGE sum 0 -1 withscores    <span class="hljs-comment"># 合并后的Zset score是两集合中score之和</span>
1) <span class="hljs-string">"Tom"</span>
2) <span class="hljs-string">"164"</span>
3) <span class="hljs-string">"Joe"</span>
4) <span class="hljs-string">"170"</span>
5) <span class="hljs-string">"Mike"</span>
6) <span class="hljs-string">"178"</span>
127.0.0.1:6379&gt; ZUNIONSTORE low 2 marh en AGGREGATE MIN
(<span class="hljs-built_in">integer</span>) 3                                   <span class="hljs-comment"># 取两个集合的成员score最小值作为结果</span>
127.0.0.1:6379&gt; ZRANGE low 0 -1 withscores
1) <span class="hljs-string">"Tom"</span>
2) <span class="hljs-string">"76"</span>
3) <span class="hljs-string">"Mike"</span>
4) <span class="hljs-string">"88"</span>
5) <span class="hljs-string">"Joe"</span>
6) <span class="hljs-string">"90"</span></code></pre>

<h2 id="Redis三种特殊数据类型"><a href="#Redis三种特殊数据类型" class="headerlink" title="Redis三种特殊数据类型"></a>Redis三种特殊数据类型</h2><h3 id="Geospatial-地理位置"><a href="#Geospatial-地理位置" class="headerlink" title="Geospatial(地理位置)"></a>Geospatial(地理位置)</h3><p>Geospatial是使用经纬度定位地理坐标并用一个<strong>有序集合zset保存</strong>，所以Zset命令也可以使用</p>
<blockquote>
<p>有效经纬度</p>
</blockquote>
<p>经度[-180,180]    纬度[-85.05112878,85.05112878]</p>
<pre><code class="hljs bash"><span class="hljs-comment"># GEOADD</span>
127.0.0.1:6379&gt; GEOADD china:city 116.405285 39.904989 beijing       <span class="hljs-comment"># 将具体经纬度的坐标存入一个有序集合</span>
(<span class="hljs-built_in">integer</span>) 1
127.0.0.1:6379&gt; GEOADD china:city 121.472644 31.231706 shanghai
(<span class="hljs-built_in">integer</span>) 1
127.0.0.1:6379&gt; GEOADD china:city 113.280637 23.125178 guangzhou
(<span class="hljs-built_in">integer</span>) 1
127.0.0.1:6379&gt; GEOADD china:city 114.085947 22.547 shenzhen
(<span class="hljs-built_in">integer</span>) 1
127.0.0.1:6379&gt; GEOADD china:city 114.177314 22.266416 hongkong
(<span class="hljs-built_in">integer</span>) 1
<span class="hljs-comment">######################################################################################</span>
<span class="hljs-comment"># GEOPOS       获取集合中的一个/多个成员坐标</span>
127.0.0.1:6379&gt; GEOPOS china:city beijing               
1) 1) <span class="hljs-string">"116.40528291463851929"</span>
   2) <span class="hljs-string">"39.9049884229125027"</span>
127.0.0.1:6379&gt; GEOPOS china:city beijing hongkong
1) 1) <span class="hljs-string">"116.40528291463851929"</span>
   2) <span class="hljs-string">"39.9049884229125027"</span>
2) 1) <span class="hljs-string">"114.17731136083602905"</span>
   2) <span class="hljs-string">"22.26641644428547551"</span>
<span class="hljs-comment">######################################################################################</span>
<span class="hljs-comment"># GEODIST      返回两个给定位置之间的距离 默认为m</span>
<span class="hljs-comment"># 单位参数 m-米 km-千米 mi-英里 ft-英尺</span>
127.0.0.1:6379&gt; GEODIST china:city guangzhou shenzhen km
<span class="hljs-string">"104.6426"</span>
127.0.0.1:6379&gt; GEODIST china:city guangzhou hongkong m
<span class="hljs-string">"132624.2824"</span>
<span class="hljs-comment">######################################################################################</span>
<span class="hljs-comment"># GEORADIUS 给定的经纬度为中心， 返回集合包含的位置元素</span>
127.0.0.1:6379&gt; GEORADIUS china:city 115 22.6 100 km  <span class="hljs-comment"># 给定的经纬度为中心 100 km以内</span>
1) <span class="hljs-string">"hongkong"</span>
2) <span class="hljs-string">"shenzhen"</span>
127.0.0.1:6379&gt; GEORADIUS china:city 115 22.6 100 km withdist  <span class="hljs-comment"># 附带距给定位置举例</span>
1) 1) <span class="hljs-string">"hongkong"</span>
   2) <span class="hljs-string">"92.3601"</span>
2) 1) <span class="hljs-string">"shenzhen"</span>
   2) <span class="hljs-string">"94.0628"</span>
127.0.0.1:6379&gt; GEORADIUS china:city 115 22.6 100 km withcoord  <span class="hljs-comment"># 附带城市的定位信息</span>
1) 1) <span class="hljs-string">"hongkong"</span>
   2) 1) <span class="hljs-string">"114.17731136083602905"</span>
      2) <span class="hljs-string">"22.26641644428547551"</span>
2) 1) <span class="hljs-string">"shenzhen"</span>
   2) 1) <span class="hljs-string">"114.08594459295272827"</span>
      2) <span class="hljs-string">"22.54699993773966327"</span>
127.0.0.1:6379&gt; GEORADIUS china:city 115 22.6 100 km withdist withcoord count 1  <span class="hljs-comment"># 筛选出最近的 1 个</span>
1) 1) <span class="hljs-string">"hongkong"</span>
   2) <span class="hljs-string">"92.3601"</span>
   3) 1) <span class="hljs-string">"114.17731136083602905"</span>
      2) <span class="hljs-string">"22.26641644428547551"</span>     
<span class="hljs-comment">######################################################################################</span>
<span class="hljs-comment"># GEORADIUSBYMEMBER 返回指定元素周围的其他元素     </span>
127.0.0.1:6379&gt; GEORADIUSBYMEMBER china:city shenzhen 500 km
1) <span class="hljs-string">"hongkong"</span>
2) <span class="hljs-string">"shenzhen"</span>
3) <span class="hljs-string">"guangzhou"</span>
<span class="hljs-comment">######################################################################################</span>
<span class="hljs-comment"># GEOHASH 返回一个或多个位置元素的Geohash表示 如果两个字符串越接近，则距离越近</span>
127.0.0.1:6379&gt; GEOHASH china:city guangzhou shenzhen
1) <span class="hljs-string">"ws0e9cb3yj0"</span>
2) <span class="hljs-string">"ws10k0dcg10"</span></code></pre>

<h3 id="Hyperloglog-基数统计"><a href="#Hyperloglog-基数统计" class="headerlink" title="Hyperloglog(基数统计)"></a>Hyperloglog(基数统计)</h3><p>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。缺点：0.81%错误率，如果不允许错误使用set类型</p>
<p>花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。</p>
<p>因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。其底层使用string数据类型.</p>
<p>应用场景：网页的访问量（UV）</p>
<pre><code class="hljs bash">127.0.0.1:6379&gt; PFADD myelemx a b c d e f              <span class="hljs-comment"># 添加指定元素到 HyperLogLog 中</span>
(<span class="hljs-built_in">integer</span>) 1
127.0.0.1:6379&gt; <span class="hljs-built_in">type</span> myelemx                           <span class="hljs-comment"># hyperloglog底层使用String</span>
string
127.0.0.1:6379&gt; PFCOUNT myelemx                        <span class="hljs-comment"># 返回给定 HyperLogLog 的基数估算值</span>
(<span class="hljs-built_in">integer</span>) 6
127.0.0.1:6379&gt; PFADD myelemy e f 1 2 3 4 5
(<span class="hljs-built_in">integer</span>) 1
127.0.0.1:6379&gt; PFCOUNT myelemy
(<span class="hljs-built_in">integer</span>) 7
127.0.0.1:6379&gt; PFMERGE myelemz myelemx myelemy        <span class="hljs-comment"># 将多个 HyperLogLog 合并为一个 HyperLogLog</span>
OK
127.0.0.1:6379&gt; PFCOUNT myelemz                        <span class="hljs-comment"># 合并后估算的基数值</span>
(<span class="hljs-built_in">integer</span>) 11</code></pre>

<h3 id="BitMaps-位图"><a href="#BitMaps-位图" class="headerlink" title="BitMaps(位图)"></a>BitMaps(位图)</h3><p>Bitmap是一串连续的2进制数字（0或1），使用<strong>位存储</strong>，信息状态只有0和1</p>
<p>场景：用户状态，签到情况等</p>
<pre><code class="hljs bash">127.0.0.1:6379&gt; SETBIT sign 0 1       <span class="hljs-comment"># 为指定key的offset位设置值</span>
(<span class="hljs-built_in">integer</span>) 0
127.0.0.1:6379&gt; SETBIT sign 1 1
(<span class="hljs-built_in">integer</span>) 0
127.0.0.1:6379&gt; SETBIT sign 2 0
(<span class="hljs-built_in">integer</span>) 0
127.0.0.1:6379&gt; SETBIT sign 3 1
(<span class="hljs-built_in">integer</span>) 0
127.0.0.1:6379&gt; SETBIT sign 5 1
(<span class="hljs-built_in">integer</span>) 0
127.0.0.1:6379&gt; <span class="hljs-built_in">type</span> sign
string
127.0.0.1:6379&gt; GETBIT sign 0         <span class="hljs-comment"># 获取指定offset位的值</span>
(<span class="hljs-built_in">integer</span>) 1
127.0.0.1:6379&gt; GETBIT sign 2
(<span class="hljs-built_in">integer</span>) 0
127.0.0.1:6379&gt; GETBIT sign 4
(<span class="hljs-built_in">integer</span>) 0
127.0.0.1:6379&gt; BITCOUNT sign         <span class="hljs-comment"># 统计字符串被设置为1的bit数</span>
(<span class="hljs-built_in">integer</span>) 4</code></pre>

<h2 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h2><h3 id="Redis事务本质"><a href="#Redis事务本质" class="headerlink" title="Redis事务本质"></a>Redis事务本质</h3><p>Redis事务本质：一组命令的集合，事务中每条命令都会被序列化，执行过程中按顺序执行，不允许其他命令进行干扰。</p>
<p><strong>一次性、顺序性、排他性</strong></p>
<p>Redis的单条命令具有原子性，但Redis事务不保证原子性</p>
<h3 id="Redis事务操作过程"><a href="#Redis事务操作过程" class="headerlink" title="Redis事务操作过程"></a>Redis事务操作过程</h3><ol>
<li>开启事务（multi）</li>
<li>命令入队</li>
<li>执行事务（exec）</li>
</ol>
<p>事务中所有命令在加入时都没有被执行，直到提交时才会开始执行(Exec)一次性完成</p>
<pre><code class="hljs bash">127.0.0.1:6379&gt; multi         <span class="hljs-comment"># 开启事务</span>
OK
127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> k1 v1     <span class="hljs-comment"># 命令入队</span>
QUEUED
127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> k2 v2
QUEUED
127.0.0.1:6379&gt; keys *
QUEUED
127.0.0.1:6379&gt; get k1
QUEUED
127.0.0.1:6379&gt; <span class="hljs-built_in">exec</span>          <span class="hljs-comment"># 执行事务</span>
1) OK
2) OK
3) 1) <span class="hljs-string">"k2"</span>
   2) <span class="hljs-string">"k1"</span>
4) <span class="hljs-string">"v1"</span></code></pre>

<h3 id="取消事务"><a href="#取消事务" class="headerlink" title="取消事务"></a>取消事务</h3><pre><code class="hljs bash">127.0.0.1:6379&gt; multi
OK
127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> k1 v1
QUEUED
127.0.0.1:6379&gt; DISCARD            <span class="hljs-comment"># 取消事务</span>
OK
127.0.0.1:6379&gt; EXEC               <span class="hljs-comment"># 事务已取消，无法执行</span>
(error) ERR EXEC without MULTI     <span class="hljs-comment"># 当前未开启事务</span>
127.0.0.1:6379&gt; get k1             <span class="hljs-comment"># 被放弃的事务中命令未执行</span>
(nil)</code></pre>

<h3 id="事务错误"><a href="#事务错误" class="headerlink" title="事务错误"></a>事务错误</h3><ul>
<li><p>编译时错误：代码语法错误，所有命令都不执行</p>
<pre><code class="hljs bash">127.0.0.1:6379&gt; multi
OK
127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> k1 v1
QUEUED
127.0.0.1:6379&gt; getset k2        <span class="hljs-comment"># 语法错误，报错不影响后续命令入队</span>
(error) ERR wrong number of arguments <span class="hljs-keyword">for</span> <span class="hljs-string">'getset'</span> <span class="hljs-built_in">command</span>
127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> k3 v3
QUEUED
127.0.0.1:6379&gt; get k1
QUEUED
127.0.0.1:6379&gt; <span class="hljs-built_in">exec</span>             <span class="hljs-comment"># 执行报错 </span>
(error) EXECABORT Transaction discarded because of previous errors.
127.0.0.1:6379&gt; get k1
(nil)                            <span class="hljs-comment"># 其他命令未被执行</span></code></pre>
</li>
<li><p>运行时错误：代码逻辑错误，其他正常命令正常执行    <strong>（不保证事务原子性）</strong></p>
<pre><code class="hljs bash">127.0.0.1:6379&gt; multi
OK
127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> k1 v1
QUEUED
127.0.0.1:6379&gt; incr k1        <span class="hljs-comment"># 逻辑错误，无法对字符串增量</span>
QUEUED
127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> k2 v2
QUEUED
127.0.0.1:6379&gt; get k2
QUEUED
127.0.0.1:6379&gt; <span class="hljs-built_in">exec</span>
1) OK
2) (error) ERR value is not an <span class="hljs-built_in">integer</span> or out of range  <span class="hljs-comment"># 运行时报错</span>
3) OK
4) <span class="hljs-string">"v2"</span>                                                 <span class="hljs-comment"># 不影响后续命令运行</span></code></pre>


</li>
</ul>
<h3 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h3><p>悲观锁：</p>
<ul>
<li>认为什么时候都会出现问题，无论什么操作都会加锁</li>
</ul>
<p>乐观锁：</p>
<ul>
<li>认为什么时候都不会出现问题，所以不会上锁！更新数据的时候去判断一下，在此期间是否有人修改过这个数据</li>
<li>获取version</li>
<li>更新的时候比较version</li>
</ul>
<p>使用<code>watch</code>监控指定数据，相当于加乐观锁</p>
<pre><code class="hljs bash">127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> money 100      <span class="hljs-comment"># 设置余额为100</span>
OK
127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> used 0         <span class="hljs-comment"># 支出为0</span>
OK
127.0.0.1:6379&gt; watch money        <span class="hljs-comment"># 监视 money 上锁</span>
OK
127.0.0.1:6379&gt; multi              <span class="hljs-comment"># 开启事务</span>
OK
127.0.0.1:6379&gt; DECRBY money 10    <span class="hljs-comment"># 余额变动</span>
QUEUED
127.0.0.1:6379&gt; INCRBY used 10
QUEUED
127.0.0.1:6379&gt; <span class="hljs-built_in">exec</span>               <span class="hljs-comment"># 监视值没有发生变化，事务执行成功</span>
1) (<span class="hljs-built_in">integer</span>) 90
2) (<span class="hljs-built_in">integer</span>) 10</code></pre>

<p>模拟另一个线程插队，修改余额</p>
<pre><code class="hljs bash"><span class="hljs-comment"># 线程1</span>
127.0.0.1:6379&gt; watch money       <span class="hljs-comment"># money 上锁</span>
OK
127.0.0.1:6379&gt; multi
OK
127.0.0.1:6379&gt; DECRBY money 15
QUEUED
127.0.0.1:6379&gt; INCRBY used 15
QUEUED
127.0.0.1:6379&gt;                   <span class="hljs-comment"># 线程1事务没有执行</span>
<span class="hljs-comment">######################################################################################</span>
<span class="hljs-comment"># 线程2</span>
127.0.0.1:6379&gt; INCRBY money 100  <span class="hljs-comment"># 此时修改余额</span>
(<span class="hljs-built_in">integer</span>) 190
<span class="hljs-comment">######################################################################################</span>
<span class="hljs-comment"># 线程1</span>
127.0.0.1:6379&gt; EXEC              <span class="hljs-comment"># 线程2插队后，执行</span>
(nil)                             <span class="hljs-comment"># 事务执行失败</span>
127.0.0.1:6379&gt; get money         <span class="hljs-comment"># 线程2修改生效</span>
<span class="hljs-string">"190"</span>
127.0.0.1:6379&gt; get used          <span class="hljs-comment"># 线程1事务执行失败，支出发生没有改变</span>
<span class="hljs-string">"10"</span></code></pre>

<p>解锁<code>unwatch</code>，再重新加锁执行事务。</p>
<p>注：每次执行<code>exec</code>后，无论是否成功，都会自动释放锁</p>
<h2 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h2><h3 id="普通Java项目"><a href="#普通Java项目" class="headerlink" title="普通Java项目"></a>普通Java项目</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestTX</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        Jedis jedis = <span class="hljs-keyword">new</span> Jedis(<span class="hljs-string">"xxx.xxx.xxx.xxx"</span>,<span class="hljs-number">6379</span>);
        System.out.println(<span class="hljs-string">"flushDB==&gt;"</span>+jedis.flushDB());
        JSONObject jsonObject = <span class="hljs-keyword">new</span> JSONObject();
        jsonObject.put(<span class="hljs-string">"username"</span>,<span class="hljs-string">"Mike"</span>);
        jsonObject.put(<span class="hljs-string">"pwd"</span>,<span class="hljs-string">"123456"</span>);
        Transaction multi = jedis.multi();
        String string = jsonObject.toString();
        <span class="hljs-keyword">try</span> &#123;
            multi.set(<span class="hljs-string">"user1"</span>,string);
            multi.set(<span class="hljs-string">"user2"</span>,string);
            <span class="hljs-comment">// 执行事务</span>
            multi.exec();
        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
            <span class="hljs-comment">// 放弃事务</span>
            multi.discard();
            e.printStackTrace();
        &#125; <span class="hljs-keyword">finally</span> &#123;
            System.out.println(jedis.get(<span class="hljs-string">"user1"</span>));
            System.out.println(jedis.get(<span class="hljs-string">"user2"</span>));
            jedis.close();
        &#125;
    &#125;
&#125;</code></pre>

<h3 id="整合Spring-Boot"><a href="#整合Spring-Boot" class="headerlink" title="整合Spring Boot"></a>整合Spring Boot</h3><ol>
<li><p>导入依赖</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre>
</li>
<li><p>编写配置文件</p>
<pre><code class="hljs properties"><span class="hljs-comment"># 配置Redis</span>
<span class="hljs-meta">spring.redis.host</span>=<span class="hljs-string">xxx.xxx.xxx.xxx   # redis ip </span>
<span class="hljs-meta">spring.redis.port</span>=<span class="hljs-string">6379</span></code></pre>
</li>
<li><p>使用RedisTemplate</p>
<pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Redis02SpringbootApplicationTests</span> </span>&#123;

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;
    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-comment">// 获取连接对象</span>
        RedisConnection connection = redisTemplate.getConnectionFactory().getConnection();
        connection.flushDb();
        redisTemplate.opsForValue().set(<span class="hljs-string">"k1"</span>,<span class="hljs-string">"v1"</span>);
        System.out.println(redisTemplate.opsForValue().get(<span class="hljs-string">"k1"</span>));
    &#125;
&#125;</code></pre>

<p>opsForValue() 操作字符串 String</p>
<p>opsForList 操作List</p>
</li>
<li><p>查看测试结果</p>
<pre><code class="hljs bash">xxx.xxx.xxx.xxx:6379&gt; KEYS *
1) <span class="hljs-string">"\xac\xed\x00\x05t\x00\x02k1"</span></code></pre>

<p>原因：网络中传输的对象需要序列化，否则全是乱码</p>
</li>
<li><p>定制RedisTemplate模版</p>
<pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisConfig</span> </span>&#123;
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"all"</span>)
    <span class="hljs-function"><span class="hljs-keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="hljs-title">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory redisConnectionFactory)</span> <span class="hljs-keyword">throws</span> UnknownHostException </span>&#123;
        <span class="hljs-comment">// 将template 泛型设置为 &lt;String, Object&gt;</span>
        RedisTemplate&lt;String, Object&gt; template = <span class="hljs-keyword">new</span> RedisTemplate&lt;String, Object&gt;();
        <span class="hljs-comment">// 连接工厂，不必修改</span>
        template.setConnectionFactory(redisConnectionFactory);
        <span class="hljs-comment">/*</span>
<span class="hljs-comment">         * 序列化设置</span>
<span class="hljs-comment">         */</span>
        <span class="hljs-comment">// Json 序列化配置</span>
        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="hljs-keyword">new</span> Jackson2JsonRedisSerializer(Object<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
        ObjectMapper om = <span class="hljs-keyword">new</span> ObjectMapper();
        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
        jackson2JsonRedisSerializer.setObjectMapper(om);
        StringRedisSerializer stringRedisSerializer = <span class="hljs-keyword">new</span> StringRedisSerializer();
        <span class="hljs-comment">// key、hash的key 采用 String序列化方式</span>
        template.setKeySerializer(stringRedisSerializer);
        template.setHashKeySerializer(stringRedisSerializer);
        <span class="hljs-comment">// value、hash的value 采用 Jackson 序列化方式</span>
        template.setValueSerializer(jackson2JsonRedisSerializer);
        template.setHashValueSerializer(jackson2JsonRedisSerializer);
        template.afterPropertiesSet();

        <span class="hljs-keyword">return</span> template;
    &#125;
&#125;</code></pre>

<p>测试</p>
<pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Redis02SpringbootApplicationTests</span> </span>&#123;

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;
    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params">()</span> </span>&#123;
        User liam = <span class="hljs-keyword">new</span> User(<span class="hljs-string">"Liam"</span>, <span class="hljs-string">"123456"</span>);
        RedisConnection connection = redisTemplate.getConnectionFactory().getConnection();
        connection.flushDb();
        redisTemplate.opsForValue().set(<span class="hljs-string">"user"</span>,liam);
        System.out.println(redisTemplate.opsForValue().get(<span class="hljs-string">"user"</span>));
    &#125;
&#125;</code></pre>

<p>导入RedisUtil工具类</p>
<p><a href="https://www.cnblogs.com/leeego-123/p/10511856.html" target="_blank" rel="noopener">RedisUtil</a></p>
</li>
</ol>
<h2 id="Redis配置文件-redis-conf"><a href="#Redis配置文件-redis-conf" class="headerlink" title="Redis配置文件 redis.conf"></a>Redis配置文件 redis.conf</h2><ul>
<li><p>容量单位不区分大小写，G和GB有区别</p>
<p><img src="https://gitee.com/jiantian99/Images-Hosting/raw/master/img/20200909214627.png" srcset="/img/loading.gif" alt></p>
</li>
<li><p>可以使用<code>include</code>包含多个配置文件</p>
<pre><code class="hljs bash"><span class="hljs-comment"># include /path/to/local.conf</span>
<span class="hljs-comment"># include /path/to/other.conf</span></code></pre>
</li>
<li><p>网络配置   NETWORK</p>
<pre><code class="hljs bash"><span class="hljs-built_in">bind</span> 127.0.0.1         <span class="hljs-comment"># 绑定的IP         默认是本机</span>
protected-mode yes     <span class="hljs-comment"># 是否开启保护模式  默认开启</span>
port 6379              <span class="hljs-comment"># redis 端口号     默认6379</span></code></pre>
</li>
<li><p>通用          GENERAL</p>
<pre><code class="hljs bash">daemonize yes           <span class="hljs-comment"># 以守护进程方式运行    默认 no</span>
pidfile /var/run/redis_6379.pid   <span class="hljs-comment"># 如果以守护进程方式运行，指定的pid文件</span>

<span class="hljs-comment"># 日志</span>
<span class="hljs-comment"># Specify the server verbosity level.</span>
<span class="hljs-comment"># This can be one of:</span>
<span class="hljs-comment"># debug模式，记录大量信息，用于开发和测试</span>
<span class="hljs-comment"># debug (a lot of information, useful for development/testing)     </span>
<span class="hljs-comment"># verbose模式，记录较多信息，近似于debug</span>
<span class="hljs-comment"># verbose (many rarely useful info, but not a mess like the debug level)</span>
<span class="hljs-comment"># notice模式，记录部分重要信息，用于生产环境   默认</span>
<span class="hljs-comment"># notice (moderately verbose, what you want in production probably)</span>
<span class="hljs-comment"># warning模式 记录警告等重要信息</span>
<span class="hljs-comment"># warning (only very important / critical messages are logged)</span>
loglevel notice
logfile <span class="hljs-string">""</span>             <span class="hljs-comment"># 日志生成的文件名，默认为空，指标准输出</span>
databases 16           <span class="hljs-comment"># Redis数据库数量  默认16</span>
always-show-logo yes   <span class="hljs-comment"># 是否显示logo     默认yes</span></code></pre>
</li>
<li><p>快照           SNAPSHOTTING</p>
<pre><code class="hljs bash"><span class="hljs-comment"># 持久化操作</span>
<span class="hljs-comment"># 900s内，如果有至少1个key发生变化，则进行持久化操作</span>
save 900 1
<span class="hljs-comment"># 300s内，如果有至少10个key发生变化，则进行持久化操作</span>
save 300 10
<span class="hljs-comment"># 60s内，如果有至少10000个key发生变化，则进行持久化操作</span>
save 60 10000

stop-writes-on-bgsave-error yes   <span class="hljs-comment"># 如果持久化失败，是否停止操作     默认为yes</span>
rdbcompression yes                <span class="hljs-comment"># rdb文件是否压缩 需要消耗cpu资源  默认为yes</span>
rdbchecksum yes                   <span class="hljs-comment"># 保存rdb时，是否进行检查         默认为yes</span>
dir ./                            <span class="hljs-comment"># rdb保存路径</span></code></pre>
</li>
<li><p>主从复制 REPLICATION </p>
</li>
<li><p>安全 SECURITY</p>
<p>可以修改密码</p>
</li>
<li><p>客户端配置 CLIENTS</p>
<pre><code class="hljs bash"><span class="hljs-comment"># maxclients 10000  最大客户端数</span></code></pre>
</li>
<li><p>内存 MEMORY</p>
<pre><code class="hljs bash"><span class="hljs-comment"># maxmemory &lt;bytes&gt;                 最大内存容量</span>
<span class="hljs-comment"># maxmemory-policy noeviction       内存满的处理策略</span>
<span class="hljs-comment"># 1.volatile-lru       只对设置了过期时间的key进行LRU（默认值）</span>
<span class="hljs-comment"># allkeys-lru          删除lru算法的key</span>
<span class="hljs-comment"># 3.volatile-random    随机删除即将过期key</span>
<span class="hljs-comment"># 4.allkeys-random     随机删除</span>
<span class="hljs-comment"># 5.volatile-ttl       删除即将过期的</span>
<span class="hljs-comment"># 6.noeviction         永不过期，返回错误</span></code></pre>
</li>
<li><p>aof配置  APPEND ONLY MODE</p>
<pre><code class="hljs bash">appendonly no                     <span class="hljs-comment"># aof是否开启 默认关闭     大部分情况下rdb足够使用</span>
appendfilename <span class="hljs-string">"appendonly.aof"</span>   <span class="hljs-comment"># aof持久化文件</span>
<span class="hljs-comment"># appendfsync always              # 每一次修改</span>
appendfsync everysec              <span class="hljs-comment"># 每秒执行一次 sync 可能会失去这一秒的数据</span>
<span class="hljs-comment"># appendfsync no                  # 不执行同步  此时操作系统执行同步，速度最快</span></code></pre>

</li>
</ul>
<h2 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h2><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><blockquote>
<p>什么是RDB</p>
</blockquote>
<p>RDB：Redis Databases，RDB是Redis用来进行持久化的一种方式，是把当前内存中的数据集快照写入磁盘，也就是 Snapshot 快照（数据库中所有键值对数据）。恢复数据时，直接将快照文件直接读到内存里。默认配置，数据集快照保存到<code>dump.rdb</code>的二进制文件中，文件名可以在Redis配置文件中自定义</p>
<blockquote>
<p>工作原理</p>
</blockquote>
<p>在进行RDB操作中，Redis主线程不进行IO操作，此时主线程会<code>fork</code>一个子线程来进行RDB。子进程讲数据集写入一个临时的RDB文件中，父进程依旧接收客户端的请求。当子进程完成新的RDB文件写入后，Redis会用该新的RDB文件替换旧的RDB文件。（写时复制机制）</p>
<blockquote>
<p>触发机制</p>
</blockquote>
<ol>
<li><p>满足<code>save</code>规则，自动执行RDB机制</p>
<p>使用<code>save</code>命令时，会立刻对当前内存中的数据进行持久化，但会造成阻塞，占用Redis的主进程，不接受其他操作；如果Redis数据非常多，会造成<code>save</code>命令执行速度慢，影响所有客户端的请求。</p>
</li>
<li><p>执行<code>flushall</code>命令，自动执行RDB机制</p>
</li>
<li><p>退出redis，自动执行RDB机制</p>
</li>
</ol>
<blockquote>
<p>触发规则</p>
</blockquote>
<p>通过Redis配置文件，进行配置</p>
<pre><code class="hljs bash"><span class="hljs-comment"># 默认配置</span>
<span class="hljs-comment"># 900s内，如果有至少1个key发生变化，则进行持久化操作</span>
save 900 1
<span class="hljs-comment"># 300s内，如果有至少10个key发生变化，则进行持久化操作</span>
save 300 10
<span class="hljs-comment"># 60s内，如果有至少10000个key发生变化，则进行持久化操作</span>
save 60 10000</code></pre>

<blockquote>
<p>bgsave</p>
</blockquote>
<p><code>bgsave</code>是异步进行同步，当进行RDB操作时，Redis会继续接收其他请求</p>
<p><code>bgsave</code>与<code>save</code>对比</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>save</th>
<th>bgsave</th>
</tr>
</thead>
<tbody><tr>
<td>IO类型</td>
<td>同步</td>
<td>异步</td>
</tr>
<tr>
<td>是否阻塞</td>
<td>是</td>
<td>是（进行fork时，但速度非常快）</td>
</tr>
<tr>
<td>复杂度</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>优点</td>
<td>不消耗额外的内存</td>
<td>不阻塞客户端</td>
</tr>
<tr>
<td>缺点</td>
<td>阻塞客户端</td>
<td>fork子进程需要消耗内存</td>
</tr>
</tbody></table>
<blockquote>
<p>RDB优缺点</p>
</blockquote>
<ul>
<li><p>优点</p>
<p>适合大规模的数据恢复</p>
</li>
<li><p>缺点</p>
<ol>
<li>需要一定的时间间隔进行操作，若Redis进程崩溃，最后一次修改的数据可能消失</li>
<li>数据的完整性可能不高</li>
<li>fork子进程时，需要占用一定的内存资源</li>
</ol>
</li>
</ul>
<h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><blockquote>
<p>什么是AOF</p>
</blockquote>
<p>AOF(Append Only File)，以日志的形式来记录每个写的操作，将Redis执行过的所有指令记录下来（读操作不记录），只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。AOF默认不开启，需要到Redis配置文件中，手动开启</p>
<blockquote>
<p>工作原理</p>
</blockquote>
<ol>
<li>所有的命令写入操作追加到AOF缓冲区</li>
<li>AOF缓冲区根据<code>appendfsync</code>的配置向硬盘进行同步操作</li>
<li>定期对AOF文件进行重写<ul>
<li>解决AOF文件越来越大的问题，利用重写机制缩小文件体积。</li>
<li>重写规则：多条写入命令合并成一条；重写后AOF文件只保留最终数据的写入命令</li>
<li>手动触发：使用命令<code>bgrewriteaof</code></li>
<li>自动触发：根据Redis配置规则，如果AOF文件体积大于配置值（默认64M）则触发</li>
<li>在重写时，主进程继续响应命令，并把写入操作记录写入AOF重写缓冲区，防止数据丢失；子进程创建新的AOF文件来存储重写结果，子进程不能访问在其被创建出来之后产生的新数据。最后父进程将AOF重写缓冲区的数据写入新的AOF文件中然后使用新AOF文件替换老文件。</li>
</ul>
</li>
<li>Redis重启时，自动加载AOF文件进行数据恢复</li>
</ol>
<blockquote>
<p>redis-check-aof –fix</p>
</blockquote>
<p>如果AOF文件有错位，Redis无法启动，Redis提供一个工具<code>redis-check-aof --fix</code>修复AOF文件</p>
<pre><code class="hljs bash">redis-check-aof --fix appendonly.aof</code></pre>

<blockquote>
<p>AOF优缺点</p>
</blockquote>
<ul>
<li><p>优点</p>
<ol>
<li>每一次修改都同步，数据完整性高</li>
</ol>
</li>
<li><p>缺点</p>
<ol>
<li>默认每秒同步一次，可能会丢失这一秒的数据</li>
<li>相对于RDB，AOF文件体积大，修复效率低，运行效率低</li>
</ol>
</li>
</ul>
<h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><ol>
<li>RDB持久化方式能够在指定的时间间隔内对你的数据进行快照存储</li>
<li>AOF持久化方式记录每次对服务器<strong>写</strong>的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据,AOF命令以Reds协议追加保存每次写的操作到文件末尾, Redis还能对AOF文件进行后台重写,使得AOF文件的体积不至于过大。</li>
<li>当Redis只做缓存,如果你只希望你的数据在服务器运行的时候存在,你也可以不使用任何持久化</li>
<li>同时开启两种持久化方式<ul>
<li>在这种情况下,当 redis重启的时候会优先载入AOF文件来恢复原始的数据,因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集完整</li>
<li>RDB的数据不实时,同时使用两者时服务器重启也只会找AOF文件,那要不要只使用AOF呢?建议不要,因为RDB更适合用于备份数据库(AOF不断变化不好备份),快速重启,而且不会有AOF可能潜在的Bug,留着作为一个万一的手段。</li>
</ul>
</li>
<li>性能建议<ul>
<li>因为RDB文件只用作后备用途,建议只在Slave上持久化RDB文件,而且只要15分钟备份一次就够了,只保留<code>save 900 1</code>这条规则。</li>
<li>如果 Enable AOF,好处是在最恶劣情况下也只会丢失不超过两秒数据,启动脚本较简单只load自己的AOF文件就可以了,代价是带来了持续的IO,二是 AOF rewrite的最后将 rewrite过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可,应该尽量减少 AOF rewrite的频率,AOF重写的基础大小默认值64M太小了,可以设到5G以上,默认超过原大小100%大小重写可以改到适当的数值</li>
<li>如果不 Enable AOF,仅靠 Master- Slave Repllcation实现高可用性也可以,能省掉一大笔IO,也减少了 rewrite时带来的系统波动。代价是如果 Master/ Slave同时DOWN掉,会丢失十几分钟的数据,启动脚本也要比较两个 Master/ Slave中的RDB文件,载较新的那个,微博就是这种架构。</li>
</ul>
</li>
</ol>
<h2 id="Redis订阅发布"><a href="#Redis订阅发布" class="headerlink" title="Redis订阅发布"></a>Redis订阅发布</h2><p>Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息</p>
<p>Redis客户端可以订阅任意数量的频道</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2014/11/pubsub1.png" srcset="/img/loading.gif" alt="img"></p>
<p>频道channel1与订阅该频道的三个客户端</p>
<p><img src="https://gitee.com/jiantian99/Images-Hosting/raw/master/img/20200910121936.png" srcset="/img/loading.gif" alt></p>
<p>当有新消息通过<code>PUBLISH</code>命令发给频道channel，这条信息会发送给订阅他的三个客户端</p>
<blockquote>
<p>原理</p>
</blockquote>
<p>每个 Redis 服务器进程都维持着一个表示服务器状态的 redis.h/redisServer 结构， 结构的 pubsub_channels 属性是一个字典，这个字典用于保存订阅频道的信息。字典的键就是一个个正在被订阅的频道，字典的值是一个链表，保存所有订阅该频道的客户端。客户端订阅<code>SUBSCRIBE</code>频道，就被链接到链表尾部，退订<code>UNSUBSCRIBE</code>就从链表中移除该客户端节点。</p>
<blockquote>
<p>实例演示</p>
</blockquote>
<pre><code class="hljs bash"><span class="hljs-comment"># 客户端</span>
127.0.0.1:6379&gt; SUBSCRIBE java                <span class="hljs-comment"># 客户端client订阅了名为 java 的频道</span>
Reading messages... (press Ctrl-C to quit)    <span class="hljs-comment"># 等待接收消息</span>
1) <span class="hljs-string">"subscribe"</span>                                <span class="hljs-comment"># 订阅成功</span>
2) <span class="hljs-string">"java"</span>
3) (<span class="hljs-built_in">integer</span>) 1
<span class="hljs-comment"># 发布端</span>
127.0.0.1:6379&gt; PUBLISH java <span class="hljs-string">"Hello world"</span>    <span class="hljs-comment"># 发生消息到 java 频道</span>
(<span class="hljs-built_in">integer</span>) 1
127.0.0.1:6379&gt; PUBLISH java <span class="hljs-string">"Thank you for subscribing to my channel"</span>
(<span class="hljs-built_in">integer</span>) 1
<span class="hljs-comment"># 客户端</span>
1) <span class="hljs-string">"message"</span>                                   <span class="hljs-comment"># 接收到来自频道 java 的信息 "Hello world"</span>
2) <span class="hljs-string">"java"</span>
3) <span class="hljs-string">"Hello world"</span>
1) <span class="hljs-string">"message"</span>
2) <span class="hljs-string">"java"</span>
3) <span class="hljs-string">"Thank you for subscribing to my channel"</span></code></pre>

<blockquote>
<p>使用场景</p>
</blockquote>
<ol>
<li>实时消息系统</li>
<li>实时多人聊天</li>
<li>订阅、关注系统</li>
</ol>
<p>稍微复杂的场景，使用消息中间键MQ处理</p>
<blockquote>
<p>缺点</p>
</blockquote>
<ol>
<li>如果客户端订阅了频道，但读取消息速度不够快，会使订阅消息产生堆积，Redis输出缓冲区的体积变大，影响Redis的速度</li>
<li>数据传输可靠性不高，如果客户端掉线，就接收不到断线期间发布者发布的消息</li>
</ol>
<h2 id="Redis集群化处理"><a href="#Redis集群化处理" class="headerlink" title="Redis集群化处理"></a>Redis集群化处理</h2><blockquote>
<p>作用</p>
</blockquote>
<ol>
<li><p>数据冗余</p>
<p>主从复制实现了数据的热备份，是持久化之外的一种数据冗余的方式</p>
</li>
<li><p>故障恢复</p>
<p>当主节点故障时，从节点可以暂时替代主节点提供服务，是一种服务冗余的方式</p>
</li>
<li><p>负载均衡</p>
<p>在主从复制的基础上，配合读写分离，由主节点进行写操作，从节点进行读操作，分担服务器的负载；尤其是在多读少写的场景下，通过多个从节点分担负载，提高并发量</p>
</li>
<li><p>高可用基石</p>
<p>主从复制还是哨兵和集群能够实施的基础</p>
</li>
</ol>
<h3 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h3><blockquote>
<p>概念</p>
</blockquote>
<p>主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点（Master）,后者称为从节点（Slave），数据的复制是<strong>单向</strong>的，只能从主节点复制到从节点，主节点写为主，从节点读为主。</p>
<p>默认情况下，每台Redis服务器都是主节点，一个主节点可以拥有0~N个从节点，但每个从节点只能有一个主节点。</p>
<p>在工程项目中，使用集群很有必要，原因：</p>
<ol>
<li>从容量上，单台服务器内存容量有限，难以负载大量的请求</li>
<li>从结构上，只使用单台服务器，单点故障概率高、系统崩溃概率大</li>
</ol>
<blockquote>
<p>原理</p>
</blockquote>
<ul>
<li>从服务器发送SYNC命令，连接主服务器</li>
<li>主服务器收到SYNC命令后，执行bgsave命令生成RDB文件，并使用缓冲区记录此后所有写命令</li>
<li>主服务器bgsave执行完成后，向所有从服务器发送快照文件。发送期间，继续记录所有写命令</li>
<li>从服务器收到快照文件后，丢弃原有旧数据，载入新收到的快照</li>
<li>主服务器发送完快照文件后，向数据库写入缓冲区中的所有写命令</li>
<li>从服务器完成快照的载入后（从数据库初始化完成），开始接收命令的请求，同时执行来自主服务器缓冲区的写命令</li>
<li>每当主服务器执行一次写命令，就会向从服务器发送相同的写命令，从服务器接收并执行该写命令</li>
<li>当从服务器出现断线重连后，主服务器会将断线期间的命令发送给从服务器，进行增量复制</li>
<li>主从服务器刚刚建立连接时，会进行全量同步；全量同步结束后，进行增量同步。若有需要，从服务器可随时进行全量同步。Redis策略：优先进行增量同步，增量同步失败再进行全量同步</li>
</ul>
<blockquote>
<p>配置</p>
</blockquote>
<p>Redis配置文件需修改端口号、pid文件名、日志文件名、rdb文件名</p>
<blockquote>
<p>优缺点</p>
</blockquote>
<ul>
<li>优点<ul>
<li>支持主从复制，主机会自动将数据同步到从机，可以进行读写分离，分载主机的读操作压力，从机可以为客户端提供只读操作的服务，写操作仍然必须由主机来完成</li>
<li>Slave同样可以接受其它Slaves的连接和同步请求，这样可以有效的分载Master的同步压力</li>
<li>Master Server是以非阻塞的方式为Slaves提供服务。所以在Master-Slave同步期间，客户端仍然可以提交查询或修改请求；Slave Server同样是以非阻塞的方式完成数据同步。在同步期间，如果有客户端提交查询请求，Redis则返回同步之前的数据</li>
</ul>
</li>
<li>缺点<ul>
<li>Redis不具备自动容错和恢复功能，主机从机的宕机都会导致客户端读写请求失败，需要等待机器重启或者手动切换IP才能恢复</li>
<li>当主机宕机，宕机前有部分数据未同步到从机，客户端只能连接从机完成读操作</li>
<li>如果多个从机宕机断线，多个从机重连的时候，造成主机IO剧增</li>
<li>难于实现在线扩容</li>
</ul>
</li>
</ul>
<h3 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h3><p>主从复制的模式，当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。这不是一种推荐的方式，更多时候，我们优先考虑哨兵模式。</p>
<p>哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独立运行。其原理是哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例。</p>
<blockquote>
<p>作用</p>
</blockquote>
<ol>
<li>发送命令，让Redis服务器返回监控其运行状态，包括主、从服务器</li>
<li>当哨兵检测到主服务器宕机，会自动选举一个从机当选主机，并通过发布订阅模式通知其他从机，修改配置文件，让其他从机切换主机</li>
</ol>
<blockquote>
<p>工作模式</p>
</blockquote>
<ul>
<li>每个哨兵进程都以每秒一次的频率向整个集群的主服务器、从服务器及其他哨兵进程发送一个PING命令</li>
<li>如果有一个实例距离最后一次有效回复PING命令的时间超过了<code>down-after-milliseconds</code>设定的值（默认30s），则这个实例会被哨兵标记为<em>主观下线</em></li>
<li>如果一个主服务器被标记为主观下线，则正在监视这个主服务器的所有哨兵都要以每秒一次的频率确认主服务器是否是主观下线状态</li>
<li>当有足够数量（设定quorum值）的哨兵在指定的时间范围内确认主服务器进入主观下线状态，则主服务器被标记为<em>客观下线</em></li>
<li>一般情况下，哨兵会以10秒一次的频率向集群中所有主从服务器发送INFO命令</li>
<li>当主服务器被标记为客观下线时，哨兵会以每秒一次的频率向所有从服务器发送INFO命令</li>
<li>若没有足够数量哨兵认为主服务器下线，主服务器的客观下线状态会被移除；若主服务器重新向哨兵发送PING命令返回有效回复，主服务器的主观下线状态也被移除</li>
<li>当原主服务器重新上线后，自动转为现主服务器的从节点</li>
</ul>
<blockquote>
<p>故障切换过程</p>
</blockquote>
<p>当主服务器宕机，哨兵1先检测这个结果，但不会立刻进行故障切换，仅仅是哨兵1主观认为主服务器不可用，这种现象称为<strong>主观下线</strong>。当其他哨兵也检测到主服务器不可用时，并且已发现的哨兵数量达到一定值，哨兵之间会进行一次投票，投票结果由一个哨兵发起，进行故障切换操作。切换成功后，通过发布订阅模式，让各个哨兵把自己监控的从服务器切换主服务器，这个过程称为<strong>客观下线</strong>。</p>
<blockquote>
<p>哨兵模式配置文件 sentinel.conf</p>
</blockquote>
<p>自定义哨兵配置文件，不加入配置命令，表明使用默认配置</p>
<pre><code class="hljs bash"><span class="hljs-comment"># 哨兵sentinel实例运行的端口 默认26379</span>
port 26379
 
<span class="hljs-comment"># 哨兵sentinel的工作目录</span>
dir /tmp
 
<span class="hljs-comment"># 哨兵sentinel监控的redis主节点的 ip port </span>
<span class="hljs-comment"># master-name  自定义命名的主节点名字 只能由字母A-z、数字0-9 、这三个字符".-_"组成。</span>
<span class="hljs-comment"># quorum 当有quorum个sentinel哨兵认为master主节点失联 那么这时 客观上认为主节点失联了</span>
<span class="hljs-comment"># sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</span>
sentinel monitor mymaster 127.0.0.1 6379 1
 
<span class="hljs-comment"># 当在Redis实例中开启了requirepass foobared 授权密码 这样所有连接Redis实例的客户端都要提供密码</span>
<span class="hljs-comment"># 设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码</span>
<span class="hljs-comment"># sentinel auth-pass &lt;master-name&gt; &lt;password&gt;</span>
sentinel auth-pass mymaster password
 
 
<span class="hljs-comment"># 指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认30秒</span>
<span class="hljs-comment"># sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;</span>
sentinel down-after-milliseconds mymaster 30000
 
<span class="hljs-comment"># 这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步，</span>
<span class="hljs-comment"># 这个数字越小，完成failover所需的时间就越长，</span>
<span class="hljs-comment"># 但如果这个数字越大，就意味着越多的slave因为replication而不可用。</span>
<span class="hljs-comment"># 可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。</span>
<span class="hljs-comment"># sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt;</span>
sentinel parallel-syncs mymaster 1
 
 
 
<span class="hljs-comment"># 故障转移的超时时间 failover-timeout 可以用在以下这些方面： </span>
<span class="hljs-comment">#1. 同一个sentinel对同一个master两次failover之间的间隔时间。</span>
<span class="hljs-comment">#2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时。</span>
<span class="hljs-comment">#3. 当想要取消一个正在进行的failover所需要的时间。  </span>
<span class="hljs-comment">#4. 当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了</span>
<span class="hljs-comment"># 默认三分钟</span>
<span class="hljs-comment"># sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;</span>
sentinel failover-timeout mymaster 180000
 
<span class="hljs-comment"># SCRIPTS EXECUTION</span>
 
<span class="hljs-comment">#配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知相关人员。</span>
<span class="hljs-comment">#对于脚本的运行结果有以下规则：</span>
<span class="hljs-comment">#若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10</span>
<span class="hljs-comment">#若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行。</span>
<span class="hljs-comment">#如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同。</span>
<span class="hljs-comment">#一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。</span>
 
<span class="hljs-comment">#通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等），将会去调用这个脚本，</span>
<span class="hljs-comment">#这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信息。调用该脚本时，将传给脚本两个参数，</span>
<span class="hljs-comment">#一个是事件的类型，</span>
<span class="hljs-comment">#一个是事件的描述。</span>
<span class="hljs-comment">#如果sentinel.conf配置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无法正常启动成功。</span>
<span class="hljs-comment">#通知脚本</span>
<span class="hljs-comment"># sentinel notification-script &lt;master-name&gt; &lt;script-path&gt;</span>
  sentinel notification-script mymaster /var/redis/notify.sh
 
<span class="hljs-comment"># 客户端重新配置主节点参数脚本</span>
<span class="hljs-comment"># 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已经发生改变的信息。</span>
<span class="hljs-comment"># 以下参数将会在调用脚本时传给脚本:</span>
<span class="hljs-comment"># &lt;master-name&gt; &lt;role&gt; &lt;state&gt; &lt;from-ip&gt; &lt;from-port&gt; &lt;to-ip&gt; &lt;to-port&gt;</span>
<span class="hljs-comment"># 目前&lt;state&gt;总是“failover”,</span>
<span class="hljs-comment"># &lt;role&gt;是“leader”或者“observer”中的一个。 </span>
<span class="hljs-comment"># 参数 from-ip, from-port, to-ip, to-port是用来和旧的master和新的master(即旧的slave)通信的</span>
<span class="hljs-comment"># 这个脚本应该是通用的，能被多次调用，不是针对性的。</span>
<span class="hljs-comment"># sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt;</span>
sentinel client-reconfig-script mymaster /var/redis/reconfig.sh</code></pre>

<blockquote>
<p>优缺点</p>
</blockquote>
<ul>
<li><p>优点</p>
<ol>
<li>哨兵模式基于主从复制，具备主从复制的所有优点</li>
<li>主从可以实现自动切换，系统更健壮，可用性更好</li>
</ol>
</li>
<li><p>缺点</p>
<p>难于实现在线扩容，一旦集群数量达到上限，在线扩容麻烦</p>
</li>
</ul>
<h3 id="集群-Cluster"><a href="#集群-Cluster" class="headerlink" title="集群 Cluster"></a>集群 Cluster</h3><p>Redis 的哨兵模式基本已经可以实现高可用，读写分离 ，但是在这种模式下每台 Redis 服务器都存储相同的数据，很浪费内存，在Redis3.0上加入了 Cluster 集群模式，实现了 Redis 的分布式存储，也就是说每台 Redis 节点上存储不同的内容。</p>
<p>官方推荐，集群部署至少要 3 台以上的master节点，最好使用 3 主 3 从六个节点的模式</p>
<blockquote>
<p>特点</p>
</blockquote>
<ul>
<li>所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽</li>
<li>节点的fail是通过集群中超过半数的节点检测失效时才生效</li>
<li>客户端与 Redis 节点直连,不需要中间代理层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可。</li>
</ul>
<blockquote>
<p>工作方式</p>
</blockquote>
<p>　　在 Redis 的每一个节点上，都有这么两个东西，一个是插槽（slot），它的的取值范围是：0-16383。还有一个就是cluster，可以理解为是一个集群管理的插件。当我们的存取的 Key到达的时候，Redis 会根据 crc16的算法得出一个结果，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，通过这个值，去找到对应的插槽所对应的节点，然后直接自动跳转到这个对应的节点上进行存取操作。</p>
<p>　　为了保证高可用，redis-cluster集群引入了主从模式，一个主节点对应一个或者多个从节点，当主节点宕机的时候，就会启用从节点。当其它主节点ping一个主节点A时，如果半数以上的主节点与A通信超时，那么认为主节点A宕机了。如果主节点A和它的从节点A1都宕机了，那么该集群就无法再提供服务了。</p>
<blockquote>
<p> 优缺点</p>
</blockquote>
<ul>
<li><p>优点</p>
<ol>
<li>采用P2P模式，无中心架构</li>
<li>数据按照slot插槽分布在多个节点，节点间数据共享，可动态调整数据分布</li>
<li>可拓展，节点可动态添加或删除</li>
<li>高可用，部分节点不可用时，集群可继续使用</li>
</ol>
</li>
<li><p>缺点</p>
<ol>
<li>不能使用mset、mget等批量操作</li>
<li>不支持多数据库，Redis默认支持16个数据库，集群模式只支持1个数据库空间</li>
<li>数据通过异步复制，不保证数据的强一致性</li>
</ol>
</li>
</ul>
<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><blockquote>
<p>概念</p>
</blockquote>
<p>在默认情况下，用户请求数据时，会先在缓存(Redis)中查找，若没找到即缓存未命中，再去持久层数据库中进行查找，数量少可能问题不大，可是一旦大量的请求数据（例如秒杀场景）缓存都没有命中的话，就会全部转移到数据库上，造成数据库极大的压力，就有可能导致数据库崩溃。网络安全中也有人恶意使用这种手段进行攻击被称为洪水攻击。</p>
<blockquote>
<p>解决方案</p>
</blockquote>
<ol>
<li><p>布隆过滤器</p>
<ul>
<li>布隆过滤器是一个BIT数组，本质上是一个数据，可以根据下标快速找到数据</li>
<li>哈希映射<ul>
<li>布隆过滤器通过Hash函数对需要记录的数据进行Hash操作，得到的数组下标在BIT数组中记录值为1</li>
<li>需要判断某一数据是否存在时，布隆过滤器对该数据进行Hash，得到下标，如果该下标在数组中值为1说明数据存在，为0说明不存在</li>
</ul>
</li>
<li>布隆过滤器存在精准度问题，如果数组过于拥挤，不同的数据可能Hash同一个下标数据，因此布隆过滤器只能判断数据<strong>可能存在</strong>和<strong>一定不存在</strong></li>
<li>布隆过滤器不支持删除，因此只能保证数据一定不存在</li>
</ul>
<p><img src="https://gitee.com/jiantian99/Images-Hosting/raw/master/img/20200911101008.png" srcset="/img/loading.gif" alt></p>
</li>
<li><p>缓存空对象</p>
<ul>
<li>一次请求若在缓存和数据库中都没找到，则将持久层返回的空对象缓存起来，同时设置过期时间，用于处理后续这个请求，此后再访问这个数据，直接从缓存中获取，保护了持久层数据库</li>
<li>存在问题：<ol>
<li>把空值缓存起来，占用内存空间</li>
<li>设置了空对象的过期时间，会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响</li>
</ol>
</li>
</ul>
</li>
</ol>
<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><blockquote>
<p>概念</p>
</blockquote>
<p>一个存在的key（热点数据），在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到DB，造成瞬时DB请求量大、压力骤增。这就是缓存被击穿，只是针对其中某个key的缓存不可用而导致击穿，但是其他的key依然可以使用缓存响应。</p>
<blockquote>
<p>解决方案</p>
</blockquote>
<ol>
<li><p>设置热点数据永不过期</p>
<p>如果热点数据过多，会长期占用Redis内存</p>
</li>
<li><p>加互斥锁（分布式锁）</p>
<p>保证同时刻只有一个线程访问DB</p>
</li>
</ol>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><blockquote>
<p>概念</p>
</blockquote>
<p>缓存层出现了错误，集中在一段时间内失效，不能正常工作了。于是所有的请求都会达到存储层，发生大量的缓存穿透，存储层的调用量会暴增，造成存储层也会挂掉的情况</p>
<blockquote>
<p>解决方案</p>
</blockquote>
<ol>
<li><p>Redis高可用</p>
<p>搭建Redis集群，保证Redis的高可用性</p>
</li>
<li><p>限流降级</p>
<p>在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待</p>
</li>
<li><p>数据预热</p>
<p>在正式部署之前，先把可能的数据先预访问一遍，部分预计大量访问的数据就会加载到缓存中；在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀</p>
</li>
</ol>
<p>参考资料</p>
<ol>
<li><a href="https://www.bilibili.com/video/BV1S54y1R7SB" target="_blank" rel="noopener">狂神说Java</a></li>
<li><a href="https://www.cnblogs.com/leeego-123/p/10511856.html" target="_blank" rel="noopener">SpringBoot整合Redis及Redis工具类撰写</a></li>
<li><a href="https://www.jianshu.com/p/06ab9daf921d" target="_blank" rel="noopener">哨兵模式</a></li>
</ol>

            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/">后端开发</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Redis/">Redis</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/2020/09/05/Swagger/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">快速认识Swagger</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2020/08/26/2020-08%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/">
                        <span class="hidden-mobile">2020-08 踩坑记录</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <span>Powered by</span>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <span>Theme by</span>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


    
  <!-- 备案信息 -->
  <div class="beian">
    <a href="http://beian.miit.gov.cn/" target="_blank"
       rel="nofollow noopener">粤ICP备20069462号</a>
    
      <a
        href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44190002004892"
        rel="nofollow noopener"
        class="beian-police"
        target="_blank"
      >
        <span class="beian-police-sep">&nbsp;|&nbsp;</span>
        
          <img src="/img/police_beian.png" srcset="/img/loading.gif" alt="police-icon" />
        
        <span>粤公网安备 44190002004892号</span>
      </a>
     
  </div>


    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: 'article.markdown-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "初识Redis&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>




















</body>
</html>
